#pragma once
#include <MPMCQueue.h>
#include <condition_variable>
#include <mutex>
#include <string>
#include <memory>
#include "ShutdownUtils.h"
#include "Log.h" // For logging in the revised push

class FileQueue
{
public:
    explicit FileQueue(std::size_t cap = 1024):
    q_(cap), capacity_(cap), log_(PME_GET_LOGGER("FileQueue")) {
        if (capacity_ == 0) {
            PME_LOG_ERROR(log_, "FileQueue capacity cannot be zero.");
            throw std::invalid_argument("FileQueue capacity cannot be zero.");
        }
    }

    void push(std::string path_str)
    {
        auto uptr_to_push = std::make_unique<std::string>(std::move(path_str));
        // path_str is now moved-from, log its original value if needed before move or handle inside push.
        // For simplicity, we assume logging the moved-from uptr_to_push->c_str() in trace is acceptable if it happens.

        std::unique_lock<std::mutex> lk(mtx_);
        not_full_.wait(lk, [&] {
            // size() on queue of unique_ptrs is fine
            return shutdown::requested() || q_.size() < capacity_; 
        });

        if (shutdown::requested()) {
            return;
        }

        while (!shutdown::requested()) {
            // Try to move the unique_ptr into the queue.
            // MPMCQueue<std::unique_ptr<std::string>> should have try_push(std::unique_ptr<std::string>&&)
            if (q_.try_push(std::move(uptr_to_push))) { 
                lk.unlock(); 
                not_empty_.notify_one();
                return; // uptr_to_push is now nullptr
            }
            // If try_push failed, uptr_to_push is NOT moved from yet. It's still valid.
            PME_LOG_TRACE(log_, "try_push (unique_ptr) failed after wake; re-waiting not_full_.");
            not_full_.wait(lk, [&] {
                return shutdown::requested() || q_.size() < capacity_;
            });
        }
        // If loop terminates due to shutdown, uptr_to_push will be destroyed, freeing memory.
    }

    bool pop(std::string& out_str)
    {
        std::unique_lock<std::mutex> lk(mtx_);
        not_empty_.wait(lk, [&] {
            return shutdown::requested() || !q_.empty(); 
        });

        if (shutdown::requested() && q_.empty()) { 
             return false;
        }

        std::unique_ptr<std::string> uptr_popped;
        while (!shutdown::requested()) {
            if (q_.try_pop(uptr_popped)) { 
                if (uptr_popped) { // Ensure pointer is not null after pop
                    out_str = std::move(*uptr_popped); // Move the string content
                    lk.unlock(); 
                    not_full_.notify_one();
                    return true;
                } else {
                    // This case should ideally not happen if try_pop returns true
                    // but rigtorp::MPMCQueue::pop(T&v) might set v to default constructed if T is ptr
                    // Let's assume try_pop(unique_ptr&) will set it to nullptr if it was empty
                    // or a valid pointer. If it returned true but uptr_popped is null, it's odd.
                    PME_LOG_WARN(log_, "try_pop succeeded but returned null unique_ptr. Treating as empty.");
                    // Continue to re-wait as if queue was empty
                }
            }
            
            PME_LOG_TRACE(log_, "try_pop (unique_ptr) failed after wake; re-waiting not_empty_.");
            not_empty_.wait(lk, [&] {
                return shutdown::requested() || !q_.empty();
            });

            if (shutdown::requested() && q_.empty()) {
                return false;
            }
        }
        
        // Final drain attempt on shutdown
        if (q_.try_pop(uptr_popped)) {
            if (uptr_popped) {
                out_str = std::move(*uptr_popped);
                lk.unlock(); // Mutex is still locked here from the loop or initial lock
                not_full_.notify_one();
                return true; 
            }
        }
        return false; 
    }

    void wakeAll()
    {
        std::unique_lock<std::mutex> lk(mtx_); 
        PME_LOG_TRACE(log_, "wakeAll called, notifying all waiters.");
        not_full_.notify_all();
        not_empty_.notify_all();
    }

private:
    rigtorp::MPMCQueue<std::unique_ptr<std::string>> q_;
    const std::size_t capacity_;
    std::mutex mtx_;
    std::condition_variable not_full_, not_empty_;    
    px::Log* log_;
};
