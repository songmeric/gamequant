#include "PacketProcessor.h"
#include "Log.h"
#include <PcapFileDevice.h>
#include <Packet.h>
#include <IPv4Layer.h>
#include <TcpLayer.h>
#include <UdpLayer.h>
#include <thread>
#include <chrono>
#include <md_api/proto/spcast_v3.h>
#include <md_api/proto/spcast_v4.h>

px::Log* PacketProcessor::getLogger() {
    static px::Log* logger = PME_GET_LOGGER("PacketProcessor");
    return logger;
}

PacketProcessor::PacketProcessor(const std::unordered_map<uint64_t, LatencyStats>& mapRef, std::shared_ptr<RuntimeContext> ctx)
    : log_(getLogger()),
      tcp_reassembly_(
          onTcpMessageReadyCallback,
          this,
          onTcpConnectionStartCallback,
          onTcpConnectionEndCallback
      ),
      dropcopy_map_ref_(mapRef),
      ctx_(ctx)
{
    PME_LOG_INFO(log_, "PacketProcessor instance created.");
}

PacketProcessor::~PacketProcessor() {
    PME_LOG_INFO(log_, "PacketProcessor instance destroyed.");
}

// TCP connection lifecycle callbacks
void PacketProcessor::onTcpConnectionStartCallback(const pcpp::ConnectionData& connectionData, void* userCookie) {
    PacketProcessor* self = static_cast<PacketProcessor*>(userCookie);
    if (!self) return;
    
    uint32_t flow_id = connectionData.flowKey;
    
    // Reset ring buffer for new connection
    self->flow_buffers_[flow_id].reset();
    
    PME_LOG_INFO(self->log_, "TCP Connection Started for flow key: " << flow_id);
}

void PacketProcessor::onTcpConnectionEndCallback(const pcpp::ConnectionData& connectionData, 
                                                  pcpp::TcpReassembly::ConnectionEndReason reason, 
                                                  void* userCookie) {
    PacketProcessor* self = static_cast<PacketProcessor*>(userCookie);
    if (!self) return;
    
    uint32_t flow_id = connectionData.flowKey;
    std::string reason_str = (reason == pcpp::TcpReassembly::TcpReassemblyConnectionClosedByFIN_RST) ? "FIN/RST" : "Manually";
    
    // Check for unprocessed data before removing
    auto it = self->flow_buffers_.find(flow_id);
    if (it != self->flow_buffers_.end()) {
        if (it->second.available_data() > 0) {
            PME_LOG_WARN(self->log_, "TCP Connection Ended for flow key: " << flow_id 
                         << " with " << it->second.available_data() << " bytes unprocessed. Reason: " << reason_str);
        }
        self->flow_buffers_.erase(it);
    }
    
    PME_LOG_INFO(self->log_, "TCP Connection Ended for flow key: " << flow_id << ". Reason: " << reason_str);
}

void PacketProcessor::onTcpMessageReadyCallback(int8_t side, const pcpp::TcpStreamData& tcpData, void* userCookie) {
    PacketProcessor* self = static_cast<PacketProcessor*>(userCookie);
    if (!self) {
        PME_LOG_ERROR(PME_GET_LOGGER("PacketProcessor"), "TCP MessageReady callback: userCookie is null.");
        return;
    }
    
    uint32_t flow_id = tcpData.getConnectionData().flowKey;
    self->processTcpFlowData(flow_id, tcpData);
}

void PacketProcessor::processTcpFlowData(uint32_t flow_id, const pcpp::TcpStreamData& tcpData) {
    auto& ring = flow_buffers_[flow_id];
    
    // Write new data to ring buffer
    const uint8_t* new_data = tcpData.getData();
    size_t new_len = tcpData.getDataLength();
    
    if (new_data && new_len > 0) {
        size_t written = ring.write(new_data, new_len);
        if (written < new_len) {
            PME_LOG_WARN(log_, "Flow key: " << flow_id << " - Ring buffer full, dropped " 
                         << (new_len - written) << " bytes");
        }
    }
    
    // Process messages from ring buffer
    while (ring.available_data() >= sizeof(RazeFormatter::Header)) {
        // Peek at header
        RazeFormatter::Header header;
        ring.peek(reinterpret_cast<uint8_t*>(&header), sizeof(header));
        
        uint16_t message_len = header.packet_length;
        
        if (message_len == 0) {
            PME_LOG_ERROR(log_, "Flow key: " << flow_id << " - Invalid message length 0. Clearing buffer.");
            ring.reset();
            break;
        }
        
        if (ring.available_data() < message_len) {
            // Not enough data for complete message
            PME_LOG_DEBUG(log_, "Flow key: " << flow_id << " - Waiting for more data. Need " 
                          << message_len << " bytes, have " << ring.available_data());
            break;
        }
        
        // Check if message is contiguous in buffer
        auto [data_ptr, contiguous_size] = ring.get_contiguous_data();
        
        if (contiguous_size >= message_len) {
            // Fast path: process directly from ring buffer
            processRazeMessage(data_ptr, message_len, tcpData);
        } else {
            // Slow path: message wraps around, need to copy
            std::vector<uint8_t> temp(message_len);
            ring.peek(temp.data(), message_len);
            processRazeMessage(temp.data(), message_len, tcpData);
        }
        
        ring.consume(message_len);
    }
}

void PacketProcessor::processRazeMessage(const uint8_t* data, size_t len, const pcpp::TcpStreamData& tcpData) {
    const auto* hdr = reinterpret_cast<const RazeFormatter::Header*>(data);
    
    switch (hdr->packet_type) {
        case RazeFormatter::PacketType::unsequenced_data:
            handleUnsequencedData(reinterpret_cast<const RazeFormatter::UnsequencedHeader*>(hdr), tcpData);
            break;
        default:
            PME_LOG_WARN(log_, "Unknown RazeProtocol packet_type: " << static_cast<int>(hdr->packet_type));
            break;
    }
}

void PacketProcessor::handleUnsequencedData(RazeFormatter::UnsequencedHeader const* hdr, const pcpp::TcpStreamData& tcpData) {
    switch (hdr->message_type) {
        case RazeFormatter::MessageType::new_order:
            handleNewOrder(reinterpret_cast<RazeFormatter::NewOrder const*>(hdr), tcpData);
            break;
        default:
            PME_LOG_WARN(log_, "Ignoring packet type: " << static_cast<int>(hdr->message_type));
            break;
    }
}

void PacketProcessor::handleNewOrder(RazeFormatter::NewOrder const* hdr, const pcpp::TcpStreamData& tcpData) {
    auto it = dropcopy_map_ref_.find(static_cast<uint64_t>(hdr->data.order_token));
    if (it != dropcopy_map_ref_.end()) {
        auto stat = it->second;
        uint64_t hash = generateHash(stat.md_seq_num, stat.md_recv_time, stat.md_send_time);
        joinMap_[hash].emplace_back(tcpData.getTimeStampPrecise());
    }
}

// UDP packet processing
void PacketProcessor::processUdpPacket(pcpp::Packet& packet) {
    pcpp::UdpLayer* udpLayer = packet.getLayerOfType<pcpp::UdpLayer>();
    if (!udpLayer) {
        PME_LOG_TRACE(log_, "Packet does not have a UDP layer.");
        return;
    }
    
    pcpp::IPv4Layer* ipv4Layer = packet.getLayerOfType<pcpp::IPv4Layer>();
    if (!ipv4Layer) {
        PME_LOG_DEBUG(log_, "UDP packet is not IPv4. SrcPort: " 
                      << udpLayer->getSrcPort() << " DstPort: " << udpLayer->getDstPort());
        return;
    }
    
    uint8_t* payload = udpLayer->getLayerPayload();
    size_t payloadSize = udpLayer->getLayerPayloadSize();
    
    if (payloadSize == 0) {
        return;
    }
    
    // First byte is version in SPCAST
    uint8_t version = *payload;
    
    switch (version) {
        case 3:
            handleSPCastV3(packet, payload, payloadSize);
            break;
        case 4:
            handleSPCastV4(packet, payload, payloadSize);
            break;
        default:
            PME_LOG_TRACE(log_, "UDP payload version field: " << static_cast<int>(version));
            break;
    }
}

void PacketProcessor::handleSPCastV3(pcpp::Packet& packet, uint8_t* payload, size_t payloadSize) {
    if (payloadSize < sizeof(spcast::SpcastVersion3Traits::PacketHeader)) {
        PME_LOG_WARN(log_, "SPCASTV3: Datagram too small (" << payloadSize << " bytes)");
        return;
    }
    
    auto timestamp = timespecToTimePoint(packet.getRawPacket()->getPacketTimeStamp());
    const auto* pktHdr = reinterpret_cast<const spcast::SpcastVersion3Traits::PacketHeader*>(payload);
    
    const uint64_t recv_timestamp_ns = pktHdr->recv_timestamp_ns;
    const uint64_t send_timestamp_ns = pktHdr->send_timestamp_ns;
    
    // Process messages in packet
    const uint8_t* cursor = payload + sizeof(spcast::SpcastVersion3Traits::PacketHeader);
    const uint8_t* end = payload + payloadSize;
    
    while (cursor + sizeof(spcast::SpcastVersion3Traits::MessageHeader) <= end) {
        const auto* msgHdr = reinterpret_cast<const spcast::SpcastVersion3Traits::MessageHeader*>(cursor);
        uint16_t msg_len = msgHdr->length;
        
        if (msg_len == 0) {
            PME_LOG_WARN(log_, "SPCASTV3: Message length 0");
            break;
        }
        
        if (cursor + msg_len > end) {
            PME_LOG_WARN(log_, "SPCASTV3: Truncated message");
            break;
        }
        
        uint64_t seq = msgHdr->seq_num;
        
        // Deduplicate by sequence number
        if (seq != last_udpseq_) {
            uint64_t hash = generateHash(seq, recv_timestamp_ns, send_timestamp_ns);
            joinMap_[hash].emplace_back(timestamp);
            last_udpseq_ = seq;
        }
        
        ++spcast_v3_message_total_;
        cursor += msg_len;
    }
}

void PacketProcessor::handleSPCastV4(pcpp::Packet& packet, uint8_t* payload, size_t payloadSize) {
    // TODO: Implement SPCASTV4 handling
}

// Main processing function
std::unordered_map<uint64_t, std::vector<ParsedPacketInfo>> PacketProcessor::processFile(const std::string& filePath) {
    joinMap_.clear();
    PME_LOG_INFO(log_, "Starting to process PCAP file: " << filePath);
    
    pcpp::IFileReaderDevice* reader = pcpp::IFileReaderDevice::getReader(filePath);
    if (!reader || !reader->open()) {
        PME_LOG_ERROR(log_, "Cannot open PCAP file: " << filePath);
        delete reader;
        return joinMap_;
    }
    
    PME_LOG_INFO(log_, "Successfully opened PCAP file: " << filePath);
    
    // Clean up any existing state
    tcp_reassembly_.closeAllConnections();
    flow_buffers_.clear();
    
    // Process packets
    pcpp::RawPacket rawPacket;
    int packetCount = 0;
    int tcpCount = 0;
    int udpCount = 0;
    int otherCount = 0;
    
    while (reader->getNextPacket(rawPacket)) {
        if (ctx_->stop.load()) {
            PME_LOG_INFO(log_, "Shutdown requested during processing of file: " << filePath);
            break;
        }
        
        packetCount++;
        pcpp::Packet parsedPacket(&rawPacket);
        
        if (parsedPacket.isPacketOfType(pcpp::TCP)) {
            pcpp::TcpLayer* tcpLayer = parsedPacket.getLayerOfType<pcpp::TcpLayer>();
            pcpp::IPv4Layer* ipv4Layer = parsedPacket.getLayerOfType<pcpp::IPv4Layer>();
            
            if (tcpLayer && ipv4Layer) {
                tcp_reassembly_.reassemblePacket(parsedPacket);
                tcpCount++;
            } else {
                otherCount++;
            }
        } else if (parsedPacket.isPacketOfType(pcpp::UDP)) {
            processUdpPacket(parsedPacket);
            udpCount++;
        } else {
            otherCount++;
        }
        
        // Yield periodically to avoid hogging CPU
        if (packetCount % 200 == 0) {
            std::this_thread::sleep_for(std::chrono::microseconds(50));
        } else {
            std::this_thread::yield();
        }
    }
    
    // Clean up
    tcp_reassembly_.closeAllConnections();
    flow_buffers_.clear();
    
    PME_LOG_INFO(log_, "Finished processing PCAP file: " << filePath);
    PME_LOG_INFO(log_, "Summary - Total: " << packetCount
                       << ", TCP: " << tcpCount
                       << ", UDP: " << udpCount
                       << ", SPCastV3 Messages: " << spcast_v3_message_total_
                       << ", Other: " << otherCount);
    
    reader->close();
    delete reader;
    
    return joinMap_;
}


#pragma once
#include <string>
#include <vector>
#include <unordered_map>
#include <chrono>
#include <cstring>  // for memcpy
#include <memory>
#include <PcapFileDevice.h>
#include <Packet.h>
#include <TcpReassembly.h>
#include "Log.h"
#include <razeapi/messages/raze.hpp>
#include <razeapi/messages/xraze.hpp>
#include <md_api/proto/spcast_v3.h>
#include <md_api/proto/spcast_v4.h>
#include <boost/functional/hash.hpp>
#include "DropcopyHandler.h"
#include "RuntimeContext.h"

namespace spcast
{
    namespace SpcastVersion3Traits
    {
        using PacketHeader = md_api::proto::spcast_v3::packet_header_t;
        using MessageHeader = md_api::proto::spcast_v3::message_header_t;
    };
    
    namespace SpcastVersion4Traits
    {
        using PacketHeader = md_api::proto::spcast_v4::packet_header_t;
        using MessageHeader = md_api::proto::spcast_v4::message_header_t;
    };
}

namespace RazeFormatter
{
    using Header = xraze::header;
    using UnsequencedHeader = ::raze::unsequenced_header;
    using NewOrder = ::raze::new_order;
    using MessageType = ::raze::message_type_e;
    using PacketType = xraze::packet_type_e;
}

struct ParsedPacketInfo
{
    std::chrono::time_point<std::chrono::high_resolution_clock> ts_;
    ParsedPacketInfo(std::chrono::time_point<std::chrono::high_resolution_clock> timestamp):ts_(timestamp){}
    std::chrono::time_point<std::chrono::high_resolution_clock> getTimeStamp() const 
    {
        return ts_;
    }
};

// Zero-copy ring buffer for TCP flow reassembly
template<size_t SIZE = 65536>  // 64KB per flow
class FlowRingBuffer {
    alignas(64) uint8_t buffer_[SIZE];  // Cache line aligned
    size_t write_pos_ = 0;
    size_t read_pos_ = 0;
    
public:
    size_t available_space() const {
        return SIZE - (write_pos_ - read_pos_);
    }
    
    size_t available_data() const {
        return write_pos_ - read_pos_;
    }
    
    // Write data into buffer
    size_t write(const uint8_t* data, size_t len) {
        len = std::min(len, available_space());
        size_t write_idx = write_pos_ % SIZE;
        size_t first_part = std::min(len, SIZE - write_idx);
        
        std::memcpy(&buffer_[write_idx], data, first_part);
        if (len > first_part) {
            std::memcpy(&buffer_[0], data + first_part, len - first_part);
        }
        
        write_pos_ += len;
        return len;
    }
    
    // Peek at data without consuming
    size_t peek(uint8_t* dest, size_t len) const {
        len = std::min(len, available_data());
        size_t read_idx = read_pos_ % SIZE;
        size_t first_part = std::min(len, SIZE - read_idx);
        
        std::memcpy(dest, &buffer_[read_idx], first_part);
        if (len > first_part) {
            std::memcpy(dest + first_part, &buffer_[0], len - first_part);
        }
        
        return len;
    }
    
    // Get pointer to contiguous readable data
    std::pair<const uint8_t*, size_t> get_contiguous_data() const {
        if (available_data() == 0) return {nullptr, 0};
        
        size_t read_idx = read_pos_ % SIZE;
        size_t contiguous = std::min(available_data(), SIZE - read_idx);
        return {&buffer_[read_idx], contiguous};
    }
    
    // Consume data
    void consume(size_t len) {
        read_pos_ += std::min(len, available_data());
    }
    
    void reset() {
        write_pos_ = 0;
        read_pos_ = 0;
    }
};

class PacketProcessor {
public:
    PacketProcessor(const std::unordered_map<uint64_t, LatencyStats>& mapRef, std::shared_ptr<RuntimeContext> ctx);
    ~PacketProcessor();
    
    std::unordered_map<uint64_t, std::vector<ParsedPacketInfo>> processFile(const std::string& filePath);
    
private:
    // TCP Reassembly callbacks
    static void onTcpMessageReadyCallback(int8_t side, const pcpp::TcpStreamData& tcpData, void* userCookie);
    static void onTcpConnectionStartCallback(const pcpp::ConnectionData& connectionData, void* userCookie);
    static void onTcpConnectionEndCallback(const pcpp::ConnectionData& connectionData, pcpp::TcpReassembly::ConnectionEndReason reason, void* userCookie);
    
    // Message processing
    void processTcpFlowData(uint32_t flow_id, const pcpp::TcpStreamData& tcpData);
    void processRazeMessage(const uint8_t* data, size_t len, const pcpp::TcpStreamData& tcpData);
    
    // UDP processing
    void processUdpPacket(pcpp::Packet& packet);
    void handleSPCastV3(pcpp::Packet& packet, uint8_t* payload, size_t payloadSize);
    void handleSPCastV4(pcpp::Packet& packet, uint8_t* payload, size_t payloadSize);
    
    // RazeProtocol processing
    void handleUnsequencedData(RazeFormatter::UnsequencedHeader const* hdr, const pcpp::TcpStreamData& tcpData);
    void handleNewOrder(RazeFormatter::NewOrder const* hdr, const pcpp::TcpStreamData& tcpData);
    
    uint64_t generateHash(uint64_t seq, uint64_t recv, uint64_t send) {
        PME_LOG_INFO(log_, "Generating hash using 3 keys: " << seq << " " << recv << " " << send);
        std::size_t seed = 0;
        boost::hash_combine(seed, seq);
        boost::hash_combine(seed, recv);
        boost::hash_combine(seed, send);
        return static_cast<uint64_t>(seed);
    }
    
    static std::chrono::time_point<std::chrono::high_resolution_clock> timespecToTimePoint(const timespec& in) {
        auto duration = std::chrono::duration_cast<std::chrono::high_resolution_clock::duration>(
            std::chrono::seconds(in.tv_sec) + std::chrono::nanoseconds(in.tv_nsec));
        return std::chrono::time_point<std::chrono::high_resolution_clock>(duration);
    }
    
    uint64_t spcast_v3_message_total_ {0};
    px::Log* log_;
    pcpp::TcpReassembly tcp_reassembly_;
    std::unordered_map<uint32_t, FlowRingBuffer<>> flow_buffers_;  // Ring buffers per flow
    
    const std::unordered_map<uint64_t, LatencyStats>& dropcopy_map_ref_;
    std::shared_ptr<RuntimeContext> ctx_;
    std::unordered_map<uint64_t, std::vector<ParsedPacketInfo>> joinMap_;
    
    uint64_t last_udpseq_ {0};
    static px::Log* getLogger();
};


#include <sys/inotify.h>
#include <unistd.h>
#include <iostream>
#include <cerrno>
#include <cstring>

int main() {
    std::cout << "Testing inotify_init1..." << std::endl;
    
    // Try without any flags first
    int fd1 = inotify_init();
    std::cout << "inotify_init() returned: " << fd1;
    if (fd1 == -1) {
        std::cout << " (errno: " << errno << " - " << strerror(errno) << ")";
    }
    std::cout << std::endl;
    if (fd1 != -1) close(fd1);
    
    // Try with flags
    int fd2 = inotify_init1(IN_NONBLOCK | IN_CLOEXEC);
    std::cout << "inotify_init1(IN_NONBLOCK | IN_CLOEXEC) returned: " << fd2;
    if (fd2 == -1) {
        std::cout << " (errno: " << errno << " - " << strerror(errno) << ")";
    }
    std::cout << std::endl;
    if (fd2 != -1) close(fd2);
    
    // Try with just IN_CLOEXEC
    int fd3 = inotify_init1(IN_CLOEXEC);
    std::cout << "inotify_init1(IN_CLOEXEC) returned: " << fd3;
    if (fd3 == -1) {
        std::cout << " (errno: " << errno << " - " << strerror(errno) << ")";
    }
    std::cout << std::endl;
    if (fd3 != -1) close(fd3);
    
    // Try with 0 flags
    int fd4 = inotify_init1(0);
    std::cout << "inotify_init1(0) returned: " << fd4;
    if (fd4 == -1) {
        std::cout << " (errno: " << errno << " - " << strerror(errno) << ")";
    }
    std::cout << std::endl;
    if (fd4 != -1) close(fd4);
    
    return 0;
}


#include "Watcher.h"
#include "Log.h"
#include <array>
#include <filesystem>
#include <stdexcept>
#include <unistd.h>
#include <sys/inotify.h>
#include <cerrno>
#include <cstring>
#include <vector>
#include <fcntl.h>  // for fcntl
#include <sys/resource.h>  // for getrlimit
#include <fstream>

Watcher::Watcher(std::string dir, CB cb)
    : dir_(std::move(dir)), cb_(std::move(cb))
{
    if(!std::filesystem::is_directory(dir_))
    {
        PME_LOG_FATAL(PME_GET_LOGGER("Watcher"), "NOT A DIRECTORY: " << dir_);
        throw std::runtime_error("not a directory: " + dir_);
    }
    
    // Debug: Check system limits and current FD usage
    struct rlimit rlim;
    if (getrlimit(RLIMIT_NOFILE, &rlim) == 0) {
        PME_LOG_INFO(PME_GET_LOGGER("Watcher"), "File descriptor limits - soft: " << rlim.rlim_cur << ", hard: " << rlim.rlim_max);
    }
    
    // Count open file descriptors
    int fd_count = 0;
    std::string fd_dir = "/proc/self/fd";
    try {
        for (const auto& entry : std::filesystem::directory_iterator(fd_dir)) {
            fd_count++;
        }
        PME_LOG_INFO(PME_GET_LOGGER("Watcher"), "Current open file descriptors: " << fd_count);
    } catch (...) {
        PME_LOG_WARN(PME_GET_LOGGER("Watcher"), "Could not count file descriptors");
    }
    
    // Debug: print flag values
    PME_LOG_INFO(PME_GET_LOGGER("Watcher"), "IN_NONBLOCK = " << std::hex << IN_NONBLOCK << ", IN_CLOEXEC = " << std::hex << IN_CLOEXEC);
    PME_LOG_INFO(PME_GET_LOGGER("Watcher"), "Combined flags = " << std::hex << (IN_NONBLOCK | IN_CLOEXEC));
    
    // Save errno before any other calls
    errno = 0;
    fd_ = inotify_init1(IN_NONBLOCK | IN_CLOEXEC);
    int saved_errno = errno;
    
    PME_LOG_INFO(PME_GET_LOGGER("Watcher"), "inotify_init1 returned fd=" << fd_ << ", errno=" << saved_errno << " (" << strerror(saved_errno) << ")");
    
    if(fd_==-1)
    {
        PME_LOG_WARN(PME_GET_LOGGER("Watcher"), "inotify_init1 failed with errno " << saved_errno << ": " << strerror(saved_errno) << ", trying inotify_init");
        
        // Fallback to inotify_init
        errno = 0;
        fd_ = inotify_init();
        saved_errno = errno;
        
        PME_LOG_INFO(PME_GET_LOGGER("Watcher"), "inotify_init returned fd=" << fd_ << ", errno=" << saved_errno);
        
        if(fd_ != -1) {
            // Set flags manually
            int flags = fcntl(fd_, F_GETFL);
            fcntl(fd_, F_SETFL, flags | O_NONBLOCK);
            fcntl(fd_, F_SETFD, FD_CLOEXEC);
            PME_LOG_INFO(PME_GET_LOGGER("Watcher"), "inotify_init succeeded, fd = " << fd_ << ", flags set manually");
        } else {
            PME_LOG_FATAL(PME_GET_LOGGER("Watcher"), "Both inotify_init1 and inotify_init failed: " << strerror(saved_errno));
            throw std::runtime_error("inotify initialization failed: " + std::string(strerror(saved_errno)));
        }
    }
    
    uint32_t watch_mask = IN_CREATE | IN_MOVED_TO | IN_CLOSE_WRITE;
    wd_ = inotify_add_watch(fd_, dir_.c_str(), watch_mask);
    if(wd_==-1)
    {
        PME_LOG_FATAL(PME_GET_LOGGER("Watcher"), "add_watch failed for " << dir_ << ": " << strerror(errno));
        throw std::runtime_error("add_watch failed: " + std::string(strerror(errno)));
    }
}

Watcher::~Watcher()
{
    if(fd_ != -1) {
        if (wd_ != -1) {
            inotify_rm_watch(fd_, wd_);
        }
        close(fd_);
    }
}

void Watcher::handle()
{
    if (fd_ == -1) return;

    char buffer[4096] __attribute__ ((aligned(__alignof__(struct inotify_event))));
    ssize_t bytes_read;

    while (true) {
        bytes_read = read(fd_, buffer, sizeof(buffer));

        if (bytes_read == -1) {
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                break;
            } else if (errno == EINTR) {
                continue;
            } else {
                return;
            }
        }

        if (bytes_read == 0) {
            break;
        }

        for (char* p = buffer; p < buffer + bytes_read; ) {
            struct inotify_event* event = reinterpret_cast<struct inotify_event*>(p);

            if (event->mask & (IN_CREATE | IN_MOVED_TO | IN_CLOSE_WRITE)) {
                if (event->len > 0) {
                    cb_(event->name, event->mask);
                } else {
                }
            }
            p += sizeof(struct inotify_event) + event->len;
        }
    }
}


#pragma once
#include <MPMCQueue.h>
#include <string>
#include <memory>
#include <thread>
#include <algorithm>
#ifdef _MSC_VER
#include <intrin.h>  // For _mm_pause on Windows
#else
#include <emmintrin.h>  // For _mm_pause on Linux/Mac
#endif
#include "Log.h"
#include "RuntimeContext.h"

class FileQueue
{
public:
    explicit FileQueue(std::shared_ptr<RuntimeContext> ctx, std::size_t cap = 1024):
    q_(cap), ctx_(ctx), log_(PME_GET_LOGGER("FileQueue")){}

    void push(std::string path)
    {
        auto ptr = std::make_unique<std::string>(std::move(path));
        
        // Exponential backoff spin-wait
        int backoff = 1;
        while (!q_.try_push(std::move(ptr))) 
        {
            if (ctx_->stop.load()) return;
            
            // CPU pause instruction for spin-wait
            for (int i = 0; i < backoff; ++i) {
                _mm_pause();
            }
            
            if (backoff < 64) {
                backoff *= 2;
            } else {
                // After spinning, yield to OS
                std::this_thread::yield();
            }
        }
    }

    bool pop(std::string& out)
    {
        std::unique_ptr<std::string> ptr;
        
        // Exponential backoff spin-wait
        int backoff = 1;
        while (!q_.try_pop(ptr))
        {
            if (ctx_->stop.load()) return false;
            
            // CPU pause instruction for spin-wait
            for (int i = 0; i < backoff; ++i) {
                _mm_pause();
            }
            
            if (backoff < 64) {
                backoff *= 2;
            } else {
                // After spinning, yield to OS
                std::this_thread::yield();
            }
        }
        
        out = std::move(*ptr);
        return true;
    }

private:
    rigtorp::MPMCQueue<std::unique_ptr<std::string>> q_;
    std::shared_ptr<RuntimeContext> ctx_;
    px::Log* log_;
};



#include "Discovery.h"
#include <unistd.h> // For close()
#include <sys/epoll.h> // For epoll functions
#include <filesystem> // For path manipulation
#include <chrono> // for std::chrono
#include <thread> // for std::this_thread::sleep_for
#include <cerrno> // for errno
#include <cstring> // For strerror

// Discovery Constructor (check watcher fd)
Discovery::Discovery(std::string dir, FileQueue& q, px::Log* engine_logger, std::shared_ptr<RuntimeContext> ctx)
    : watcher_(dir, [this](std::string_view name, uint32_t mask) { onEvent(name, mask); }),
      queue_(q),
      log_(engine_logger), // Use the passed logger, or create a specific one if desired
      discovery_dir_path_(std::move(dir)), // Store the directory path
      ctx_(ctx)
{
    PME_LOG_INFO(log_, "Discovery instance for directory: " << discovery_dir_path_);
    if (watcher_.fd() < 0) {
        // Watcher constructor failed to initialize inotify.
        // This instance of Discovery is now in a bad state.
        // The run() method will check fd() and refuse to start.
        PME_LOG_ERROR(log_, "Watcher initialization failed for directory: " << discovery_dir_path_ << ". Discovery will not run.");
    }
}

struct FileAttributes {
    std::filesystem::file_time_type last_write_time;
    std::uintmax_t file_size;
    bool exists = false;
};

FileAttributes get_file_attributes(const std::filesystem::path& p, px::Log* logger) {
    FileAttributes attrs;
    try {
        if (std::filesystem::exists(p) && std::filesystem::is_regular_file(p)) {
            attrs.last_write_time = std::filesystem::last_write_time(p);
            attrs.file_size = std::filesystem::file_size(p);
            attrs.exists = true;
        }
    } catch (const std::filesystem::filesystem_error& e) {
        PME_LOG_WARN(logger, "Error getting attributes for file " << p.string() << ": " << e.what());
        attrs.exists = false; // Treat as non-existent or problematic
    }
    return attrs;
}

void Discovery::run() {
    if (watcher_.fd() < 0) {
        PME_LOG_ERROR(log_, "Watcher FD is invalid for dir '" << discovery_dir_path_ << "'. Discovery run loop cannot start.");
        return; // Indicate failure to Engine
    }

    const std::chrono::milliseconds initial_scan_stability_delay(1500); // Configurable: e.g., 1.5 seconds

    PME_LOG_INFO(log_, "Performing initial scan of directory: " << discovery_dir_path_ << " (stability delay: " << initial_scan_stability_delay.count() << "ms)");
    try {
        if (std::filesystem::exists(discovery_dir_path_) && std::filesystem::is_directory(discovery_dir_path_)) {
            std::vector<std::filesystem::path> initial_pcap_files;
            for (const auto& entry : std::filesystem::directory_iterator(discovery_dir_path_)) {
                if (ctx_->stop.load()) {
                    PME_LOG_INFO(log_, "Shutdown signaled during initial scan directory listing of " << discovery_dir_path_ << ", aborting scan.");
                    return; // Normal shutdown, not an error for discovery itself
                }
                if (entry.is_regular_file() && entry.path().extension() == ".pcap") {
                    initial_pcap_files.push_back(entry.path());
                }
            }

            for (const auto& pcap_path : initial_pcap_files) {
                if (ctx_->stop.load()) {
                    PME_LOG_INFO(log_, "Shutdown signaled during initial scan stability check of " << discovery_dir_path_ << ", aborting scan.");
                    return; // Normal shutdown, not an error for discovery itself
                }

                FileAttributes attrs1 = get_file_attributes(pcap_path, log_);
                if (!attrs1.exists) continue;

                PME_LOG_TRACE(log_, "Initial scan: First check for " << pcap_path.string() << ": size=" << attrs1.file_size << ", time=" << attrs1.last_write_time.time_since_epoch().count());

                std::this_thread::sleep_for(initial_scan_stability_delay);

                FileAttributes attrs2 = get_file_attributes(pcap_path, log_);
                if (!attrs2.exists) { // File might have been deleted during sleep
                    PME_LOG_INFO(log_, "Initial scan: File " << pcap_path.string() << " deleted during stability check.");
                    continue;
                }

                PME_LOG_TRACE(log_, "Initial scan: Second check for " << pcap_path.string() << ": size=" << attrs2.file_size << ", time=" << attrs2.last_write_time.time_since_epoch().count());

                if (attrs1.file_size == attrs2.file_size && attrs1.last_write_time == attrs2.last_write_time) {
                    PME_LOG_INFO(log_, "Found stable pre-existing PCAP file during scan: " << pcap_path.string() << ". Enqueuing.");
                    queue_.push(pcap_path.string());
                } else {
                    PME_LOG_INFO(log_, "Pre-existing PCAP file " << pcap_path.string() << " appears unstable or recently modified. Skipping enqueue. Will rely on inotify events.");
                }
            }
        } else {
            PME_LOG_ERROR(log_, "Directory '" << discovery_dir_path_ << "' does not exist or is not a directory during initial scan.");
            // This could be considered a failure for this discovery instance.
            return;
        }
    } catch (const std::filesystem::filesystem_error& e) {
        PME_LOG_ERROR(log_, "Filesystem error during initial scan of " << discovery_dir_path_ << ": " << e.what() << ". Aborting discovery for this directory.");
        return; // Indicate failure
    }
    PME_LOG_INFO(log_, "Initial scan of directory " << discovery_dir_path_ << " complete.");

    // Setup epoll after the initial scan
    int epoll_fd = epoll_create1(EPOLL_CLOEXEC);
    if (epoll_fd == -1) {
        PME_LOG_ERROR(log_, "epoll_create1 failed for dir '" << discovery_dir_path_ << "': " << strerror(errno));
        return;
    }

    struct epoll_event ev;
    ev.events = EPOLLIN;
    ev.data.fd = watcher_.fd();
    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, watcher_.fd(), &ev) == -1) {
        PME_LOG_ERROR(log_, "epoll_ctl ADD failed for dir '" << discovery_dir_path_ << "': " << strerror(errno));
        close(epoll_fd);
        return;
    }

    PME_LOG_INFO(log_, "Discovery run loop (event monitoring) starting for directory: " << discovery_dir_path_);
    constexpr int MAX_EVENTS = 10;
    struct epoll_event events[MAX_EVENTS];
    bool success = true;

    while (!ctx_->stop.load()) {
        int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, 250);

        if (nfds == -1) {
            if (errno == EINTR) {
                continue;
            }
            PME_LOG_ERROR(log_, "epoll_wait failed for dir '" << discovery_dir_path_ << "': " << strerror(errno));
            success = false;
            break;
        }

        for (int n = 0; n < nfds; ++n) {
            if (events[n].data.fd == watcher_.fd()) {
                watcher_.handle();
            }
        }
    }

    if (success) {
        PME_LOG_INFO(log_, "Discovery run loop for dir '" << discovery_dir_path_ << "' finished (event monitoring ended. Success: " << success << ").");
    } else {
        PME_LOG_ERROR(log_, "Discovery run loop for dir '" << discovery_dir_path_ << "' finished due to an error (Success: " << success << ").");
    }

    close(epoll_fd);
}

// Updated onEvent callback
void Discovery::onEvent(std::string_view filename_sv, uint32_t event_mask) {
    std::filesystem::path fs_filename = filename_sv;
    std::filesystem::path full_path = std::filesystem::path(discovery_dir_path_) / fs_filename;
    std::string full_path_str = full_path.string();

    // Filter by .pcap extension. This is a common requirement.
    if (fs_filename.extension() != ".pcap") {
        PME_LOG_TRACE(log_, "Ignoring non-pcap file event mask " << event_mask << " for '" << full_path_str << "'");
        return;
    }

    if (event_mask & IN_CLOSE_WRITE) {
        PME_LOG_INFO(log_, "PCAP file closed after write (IN_CLOSE_WRITE): '" << full_path_str << "'. Enqueuing.");
        queue_.push(std::move(full_path_str));
    } else if (event_mask & IN_MOVED_TO) {
        PME_LOG_INFO(log_, "PCAP file moved into directory (IN_MOVED_TO): '" << full_path_str << "'. Enqueuing.");
        queue_.push(std::move(full_path_str));
    } else if (event_mask & IN_CREATE) {
        PME_LOG_INFO(log_, "PCAP file created (IN_CREATE): '" << full_path_str << "'. Waiting for IN_CLOSE_WRITE or IN_MOVED_TO.");
        // Do not enqueue on IN_CREATE alone for this use case.
    } else {
        PME_LOG_TRACE(log_, "Other subscribed inotify event (" << event_mask << ") for PCAP file '" << full_path_str << "'");
    }
}


Watcher.cpp

#include "Watcher.h"
#include <filesystem>
#include <stdexcept>
#include <unistd.h>
#include <sys/inotify.h>
#include <cerrno>
#include <cstring>

Watcher::Watcher(std::string dir, CB cb)
    : dir_(std::move(dir)), cb_(std::move(cb))
{
    if (!std::filesystem::is_directory(dir_))
        throw std::runtime_error("not a directory: " + dir_);
    
    fd_ = inotify_init1(IN_NONBLOCK | IN_CLOEXEC);
    if (fd_ == -1)
        throw std::runtime_error("inotify_init1: " + std::string(strerror(errno)));
    
    wd_ = inotify_add_watch(fd_, dir_.c_str(), IN_CREATE | IN_MOVED_TO | IN_CLOSE_WRITE);
    if (wd_ == -1)
        throw std::runtime_error("inotify_add_watch: " + std::string(strerror(errno)));
}

Watcher::~Watcher()
{
    if (fd_ != -1) {
        if (wd_ != -1) inotify_rm_watch(fd_, wd_);
        close(fd_);
    }
}

void Watcher::handle()
{
    char buffer[4096] __attribute__((aligned(__alignof__(struct inotify_event))));
    
    while (auto len = read(fd_, buffer, sizeof(buffer))) {
        if (len == -1) {
            if (errno == EAGAIN || errno == EINTR) break;
            return;
        }
        
        for (char* p = buffer; p < buffer + len; ) {
            auto* event = reinterpret_cast<struct inotify_event*>(p);
            if (event->len > 0 && (event->mask & (IN_CREATE | IN_MOVED_TO | IN_CLOSE_WRITE)))
                cb_(event->name, event->mask);
            p += sizeof(struct inotify_event) + event->len;
        }
    }
}
