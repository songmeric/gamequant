#include <gtest/gtest.h>
#include "RingBuffer.h"
#include <cstring>

namespace pme {

class RingBufferTest : public ::testing::Test {
protected:
    static constexpr size_t BUFFER_SIZE = 1024;
};

// Test basic write and read
TEST_F(RingBufferTest, WriteAndRead) {
    RingBuffer buffer(BUFFER_SIZE);
    
    // Write some data
    const char* data = "Hello, World!";
    size_t data_len = strlen(data);
    
    EXPECT_EQ(buffer.write(reinterpret_cast<const uint8_t*>(data), data_len), data_len);
    EXPECT_EQ(buffer.available_data(), data_len);
    
    // Read it back
    std::vector<uint8_t> read_data(data_len);
    EXPECT_EQ(buffer.read(read_data.data(), data_len), data_len);
    
    // Verify data matches
    EXPECT_EQ(memcmp(data, read_data.data(), data_len), 0);
}

// Test multiple writes and reads
TEST_F(RingBufferTest, MultipleWritesAndReads) {
    RingBuffer buffer(BUFFER_SIZE);
    
    // Write three messages
    const char* msg1 = "First message";
    const char* msg2 = "Second message";
    const char* msg3 = "Third message";
    
    buffer.write(reinterpret_cast<const uint8_t*>(msg1), strlen(msg1));
    buffer.write(reinterpret_cast<const uint8_t*>(msg2), strlen(msg2));
    buffer.write(reinterpret_cast<const uint8_t*>(msg3), strlen(msg3));
    
    // Read all back at once
    size_t total_size = strlen(msg1) + strlen(msg2) + strlen(msg3);
    std::vector<uint8_t> all_data(total_size);
    EXPECT_EQ(buffer.read(all_data.data(), total_size), total_size);
    
    // Verify all messages are there in order
    size_t offset = 0;
    EXPECT_EQ(memcmp(all_data.data() + offset, msg1, strlen(msg1)), 0);
    offset += strlen(msg1);
    EXPECT_EQ(memcmp(all_data.data() + offset, msg2, strlen(msg2)), 0);
    offset += strlen(msg2);
    EXPECT_EQ(memcmp(all_data.data() + offset, msg3, strlen(msg3)), 0);
}

// Test consume functionality
TEST_F(RingBufferTest, ConsumeData) {
    RingBuffer buffer(BUFFER_SIZE);
    
    // Write 100 bytes
    std::vector<uint8_t> data(100, 0xAA);
    buffer.write(data.data(), data.size());
    EXPECT_EQ(buffer.available_data(), 100);
    
    // Consume 50 bytes
    buffer.consume(50);
    EXPECT_EQ(buffer.available_data(), 50);
    
    // Read remaining 50 bytes
    std::vector<uint8_t> remaining(50);
    EXPECT_EQ(buffer.read(remaining.data(), 50), 50);
    
    // Should all be 0xAA
    for (uint8_t byte : remaining) {
        EXPECT_EQ(byte, 0xAA);
    }
}

// Test wrap-around behavior
TEST_F(RingBufferTest, WrapAround) {
    RingBuffer buffer(64);  // Small buffer to force wrap
    
    // Fill most of the buffer
    std::vector<uint8_t> data1(50, 0x11);
    buffer.write(data1.data(), data1.size());
    
    // Consume some to make room at the beginning
    buffer.consume(30);
    
    // Write more data that will wrap around
    std::vector<uint8_t> data2(40, 0x22);
    buffer.write(data2.data(), data2.size());
    
    // Read all data
    std::vector<uint8_t> all_data(60);  // 20 from data1 + 40 from data2
    EXPECT_EQ(buffer.read(all_data.data(), 60), 60);
    
    // Verify first 20 bytes are 0x11
    for (int i = 0; i < 20; i++) {
        EXPECT_EQ(all_data[i], 0x11);
    }
    // Verify next 40 bytes are 0x22
    for (int i = 20; i < 60; i++) {
        EXPECT_EQ(all_data[i], 0x22);
    }
}

// Test peek functionality
TEST_F(RingBufferTest, PeekData) {
    RingBuffer buffer(BUFFER_SIZE);
    
    // Write some data
    const char* data = "Test data for peeking";
    buffer.write(reinterpret_cast<const uint8_t*>(data), strlen(data));
    
    // Peek at data without consuming  
    auto [peek_ptr, peek_size] = buffer.peek();
    EXPECT_NE(peek_ptr, nullptr);
    EXPECT_EQ(peek_size, strlen(data));
    
    // Verify buffer size hasn't changed
    EXPECT_EQ(buffer.available_data(), strlen(data));
    
    // Read normally and verify peek didn't consume
    std::vector<uint8_t> read_data(strlen(data));
    EXPECT_EQ(buffer.read(read_data.data(), strlen(data)), strlen(data));
    EXPECT_EQ(memcmp(data, read_data.data(), strlen(data)), 0);
}

// Test buffer full condition
TEST_F(RingBufferTest, BufferFull) {
    RingBuffer buffer(64);
    
    // Fill the buffer completely
    std::vector<uint8_t> data(64, 0xFF);
    EXPECT_EQ(buffer.write(data.data(), data.size()), 64);
    
    // Try to write more - should fail
    uint8_t extra = 0xEE;
    EXPECT_EQ(buffer.write(&extra, 1), 0);
    
    // Consume one byte and try again
    buffer.consume(1);
    EXPECT_EQ(buffer.write(&extra, 1), 1);
}

} // namespace pme 
