#include <gtest/gtest.h>
#include "RazeHandler.h"
#include "DropcopyHandler.h"
#include <razeapi/messages/raze.hpp>
#include "Types.h"
#include "Hash.h"
#include "RingBuffer.h"

namespace pme {

class RazeHandlerTest : public ::testing::Test {
protected:
    std::unordered_map<uint64_t, LatencyStats> dropcopy_map;
    std::unique_ptr<RazeHandler> handler;
    
    void SetUp() override {
        handler = std::make_unique<RazeHandler>(dropcopy_map);
    }
};

// Test parsing a real Raze new order message
TEST_F(RazeHandlerTest, ParseNewOrderMessage) {
    // Add dropcopy entry for order token 12345
    LatencyStats stats;
    stats.md_seq_num = 100;
    stats.md_recv_time = 1750000000000000000;
    stats.md_send_time = 1750000000000000001;
    dropcopy_map[12345] = stats;
    
    // Create a real Raze new order message
    RazeFormatter::NewOrder order;
    order.packet_length = sizeof(RazeFormatter::NewOrder);
    order.packet_type = RazeFormatter::PacketType::unsequenced_data;
    order.message_type = RazeFormatter::MessageType::new_order;
    order.data.order_token = 12345;
    
    Flow flow{"TestFlow", "Set1", Protocol{}, "", "", 0, 0, FlowDirection::INGRESS};
    auto timestamp = std::chrono::high_resolution_clock::now();
    
    auto messages = handler->getMessages(&flow, reinterpret_cast<uint8_t*>(&order), 
                                        sizeof(order), timestamp);
    
    ASSERT_EQ(messages.size(), 1);
    EXPECT_EQ(messages[0].join_key, generateHash(100, 1750000000000000000, 1750000000000000001));
}

// Test that non-new-order messages are ignored
TEST_F(RazeHandlerTest, IgnoreOtherMessageTypes) {
    // Add dropcopy entry
    LatencyStats stats;
    stats.md_seq_num = 200;
    dropcopy_map[99999] = stats;
    
    // Create a message that's not a new order
    struct OtherMessage {
        uint16_t packet_length;
        RazeFormatter::PacketType packet_type;
        RazeFormatter::MessageType message_type;
        uint64_t order_token;
    } __attribute__((packed));
    
    OtherMessage msg;
    msg.packet_length = sizeof(OtherMessage);
    msg.packet_type = RazeFormatter::PacketType::unsequenced_data;
    msg.message_type = static_cast<RazeFormatter::MessageType>(0x01); // Not new_order
    msg.order_token = 99999;
    
    Flow flow{"TestFlow", "Set1", Protocol{}, "", "", 0, 0, FlowDirection::INGRESS};
    auto timestamp = std::chrono::high_resolution_clock::now();
    
    auto messages = handler->getMessages(&flow, reinterpret_cast<uint8_t*>(&msg), 
                                        sizeof(msg), timestamp);
    
    EXPECT_TRUE(messages.empty());
}

// Test multiple new orders in one buffer
TEST_F(RazeHandlerTest, ParseMultipleOrders) {
    // Add dropcopy entries
    LatencyStats stats1;
    stats1.md_seq_num = 10;
    stats1.md_recv_time = 1750000000000000000;
    stats1.md_send_time = 1750000000000000001;
    dropcopy_map[1] = stats1;
    
    LatencyStats stats2;
    stats2.md_seq_num = 20;
    stats2.md_recv_time = 1750000000000000000;
    stats2.md_send_time = 1750000000000000001;
    dropcopy_map[2] = stats2;
    
    LatencyStats stats3;
    stats3.md_seq_num = 30;
    stats3.md_recv_time = 1750000000000000000;
    stats3.md_send_time = 1750000000000000001;
    dropcopy_map[3] = stats3;
    
    // Create buffer with 3 new orders
    std::vector<uint8_t> buffer;
    for (uint64_t token : {1, 2, 3}) {
        RazeFormatter::NewOrder order;
        order.packet_length = sizeof(RazeFormatter::NewOrder);
        order.packet_type = RazeFormatter::PacketType::unsequenced_data;
        order.message_type = RazeFormatter::MessageType::new_order;
        order.data.order_token = token;
        
        auto bytes = reinterpret_cast<uint8_t*>(&order);
        buffer.insert(buffer.end(), bytes, bytes + sizeof(order));
    }
    
    Flow flow{"TestFlow", "Set1", Protocol{}, "", "", 0, 0, FlowDirection::INGRESS};
    auto timestamp = std::chrono::high_resolution_clock::now();
    
    auto messages = handler->getMessages(&flow, buffer.data(), buffer.size(), timestamp);
    
    ASSERT_EQ(messages.size(), 3);
}

// Test TCP message length calculation
TEST_F(RazeHandlerTest, CalculateTcpMessageLength) {
    RingBuffer buffer(1024);
    
    // Write a complete message
    RazeFormatter::NewOrder order;
    order.packet_length = sizeof(RazeFormatter::NewOrder);
    order.packet_type = RazeFormatter::PacketType::unsequenced_data;
    order.message_type = RazeFormatter::MessageType::new_order;
    
    buffer.write(reinterpret_cast<uint8_t*>(&order), sizeof(order));
    
    auto reader = buffer.getReader();
    EXPECT_EQ(handler->getTcpMessageLength(reader), sizeof(RazeFormatter::NewOrder));
}

// Test missing dropcopy entry
TEST_F(RazeHandlerTest, MissingDropcopyEntry) {
    // Don't add dropcopy entry for token 54321
    
    RazeFormatter::NewOrder order;
    order.packet_length = sizeof(RazeFormatter::NewOrder);
    order.packet_type = RazeFormatter::PacketType::unsequenced_data;
    order.message_type = RazeFormatter::MessageType::new_order;
    order.data.order_token = 54321;  // No dropcopy entry for this
    
    Flow flow{"TestFlow", "Set1", Protocol{}, "", "", 0, 0, FlowDirection::INGRESS};
    auto timestamp = std::chrono::high_resolution_clock::now();
    
    auto messages = handler->getMessages(&flow, reinterpret_cast<uint8_t*>(&order), 
                                        sizeof(order), timestamp);
    
    EXPECT_TRUE(messages.empty());
}

} // namespace pme 
