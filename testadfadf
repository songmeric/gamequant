#include <gtest/gtest.h>
#include "DropcopyHandler.h"
#include <fstream>
#include <filesystem>

namespace pme {

class DropcopyHandlerTest : public ::testing::Test {
protected:
    void SetUp() override {
        test_file_ = std::filesystem::temp_directory_path() / "test_dropcopy.log";
    }

    void TearDown() override {
        std::filesystem::remove(test_file_);
    }

    void WriteTestFile(const std::string& content) {
        std::ofstream file(test_file_);
        file << content;
    }

    std::filesystem::path test_file_;
};

// Test that we can parse a real dropcopy log line
TEST_F(DropcopyHandlerTest, ParseRealDropcopyLine) {
    // This is what a real dropcopy line looks like
    std::string dropcopy_content = 
        "2024-01-15 14:30:45.123456789 [INFO] Order placed: clordid = 12345, "
        "latency_stats = {event_type=QUOTE, md_seq_num=100, md_feed_name='FEED1', "
        "md_recv_time=2024-01-15 14:30:45.100000000, md_send_time=2024-01-15 14:30:45.101000000}";
    
    WriteTestFile(dropcopy_content);
    
    DropcopyHandler handler(test_file_.string());
    auto& map = handler.getMapRef();
    
    ASSERT_EQ(map.size(), 1);
    ASSERT_TRUE(map.count(12345));
    
    auto& stats = map[12345];
    EXPECT_EQ(stats.event_type, "QUOTE");
    EXPECT_EQ(stats.md_seq_num, 100);
    EXPECT_EQ(stats.md_feed_name, "FEED1");
    EXPECT_GT(stats.md_recv_time, 0);  // Should have parsed the timestamp
    EXPECT_GT(stats.md_send_time, 0);
}

// Test parsing multiple orders
TEST_F(DropcopyHandlerTest, ParseMultipleOrders) {
    std::string dropcopy_content = 
        "2024-01-15 14:30:45.123 [INFO] Order placed: clordid = 100, "
        "latency_stats = {event_type=TRADE, md_seq_num=50}\n"
        "2024-01-15 14:30:46.456 [INFO] Order placed: clordid = 200, "
        "latency_stats = {event_type=QUOTE, md_seq_num=60}\n"
        "2024-01-15 14:30:47.789 [INFO] Order placed: clordid = 300, "
        "latency_stats = {event_type=TRADE, md_seq_num=70}\n";
    
    WriteTestFile(dropcopy_content);
    
    DropcopyHandler handler(test_file_.string());
    auto& map = handler.getMapRef();
    
    ASSERT_EQ(map.size(), 3);
    EXPECT_EQ(map[100].md_seq_num, 50);
    EXPECT_EQ(map[200].md_seq_num, 60);
    EXPECT_EQ(map[300].md_seq_num, 70);
}

// Test timestamp parsing with different precision
TEST_F(DropcopyHandlerTest, TimestampParsing) {
    DropcopyHandler handler("");
    
    // Full nanosecond precision
    uint64_t ns = handler.parseTimestamp("2024-01-15 14:30:45.123456789");
    EXPECT_EQ(ns, 1705329045123456789);
    
    // Millisecond precision
    uint64_t ms = handler.parseTimestamp("2024-01-15 14:30:45.123");
    EXPECT_EQ(ms, 1705329045123000000);
    
    // No fractional seconds
    uint64_t s = handler.parseTimestamp("2024-01-15 14:30:45");
    EXPECT_EQ(s, 1705329045000000000);
}

} // namespace pme















#include <gtest/gtest.h>
#include "RazeHandler.h"
#include "DropcopyHandler.h"
#include <razeapi/messages/raze.hpp>
#include "Types.h"
#include "Hash.h"
#include "RingBuffer.h"

namespace pme {

class RazeHandlerTest : public ::testing::Test {
protected:
    std::unordered_map<uint64_t, LatencyStats> dropcopy_map;
    std::unique_ptr<RazeHandler> handler;
    
    void SetUp() override {
        handler = std::make_unique<RazeHandler>(dropcopy_map);
    }
};

// Test parsing a real Raze new order message
TEST_F(RazeHandlerTest, ParseNewOrderMessage) {
    // Add dropcopy entry for order token 12345
    LatencyStats stats;
    stats.md_seq_num = 100;
    stats.md_recv_time = 1750000000000000000;
    stats.md_send_time = 1750000000000000001;
    dropcopy_map[12345] = stats;
    
    // Create a real Raze new order message
    RazeFormatter::NewOrder order;
    order.packet_length = sizeof(RazeFormatter::NewOrder);
    order.packet_type = RazeFormatter::PacketType::unsequenced_data;
    order.message_type = RazeFormatter::MessageType::new_order;
    order.data.order_token = 12345;
    
    Flow flow{"TestFlow", "Set1", Protocol{}, "", "", 0, 0, FlowDirection::INGRESS};
    auto timestamp = std::chrono::high_resolution_clock::now();
    
    auto messages = handler->getMessages(&flow, reinterpret_cast<uint8_t*>(&order), 
                                        sizeof(order), timestamp);
    
    ASSERT_EQ(messages.size(), 1);
    EXPECT_EQ(messages[0].join_key, generateHash(100, 1750000000000000000, 1750000000000000001));
}

// Test that non-new-order messages are ignored
TEST_F(RazeHandlerTest, IgnoreOtherMessageTypes) {
    // Add dropcopy entry
    LatencyStats stats;
    stats.md_seq_num = 200;
    dropcopy_map[99999] = stats;
    
    // Create a message that's not a new order
    struct OtherMessage {
        uint16_t packet_length;
        RazeFormatter::PacketType packet_type;
        RazeFormatter::MessageType message_type;
        uint64_t order_token;
    } __attribute__((packed));
    
    OtherMessage msg;
    msg.packet_length = sizeof(OtherMessage);
    msg.packet_type = RazeFormatter::PacketType::unsequenced_data;
    msg.message_type = static_cast<RazeFormatter::MessageType>(0x01); // Not new_order
    msg.order_token = 99999;
    
    Flow flow{"TestFlow", "Set1", Protocol{}, "", "", 0, 0, FlowDirection::INGRESS};
    auto timestamp = std::chrono::high_resolution_clock::now();
    
    auto messages = handler->getMessages(&flow, reinterpret_cast<uint8_t*>(&msg), 
                                        sizeof(msg), timestamp);
    
    EXPECT_TRUE(messages.empty());
}

// Test multiple new orders in one buffer
TEST_F(RazeHandlerTest, ParseMultipleOrders) {
    // Add dropcopy entries
    dropcopy_map[1] = {.md_seq_num = 10, .md_recv_time = 1750000000000000000, .md_send_time = 1750000000000000001};
    dropcopy_map[2] = {.md_seq_num = 20, .md_recv_time = 1750000000000000000, .md_send_time = 1750000000000000001};
    dropcopy_map[3] = {.md_seq_num = 30, .md_recv_time = 1750000000000000000, .md_send_time = 1750000000000000001};
    
    // Create buffer with 3 new orders
    std::vector<uint8_t> buffer;
    for (uint64_t token : {1, 2, 3}) {
        RazeFormatter::NewOrder order;
        order.packet_length = sizeof(RazeFormatter::NewOrder);
        order.packet_type = RazeFormatter::PacketType::unsequenced_data;
        order.message_type = RazeFormatter::MessageType::new_order;
        order.data.order_token = token;
        
        auto bytes = reinterpret_cast<uint8_t*>(&order);
        buffer.insert(buffer.end(), bytes, bytes + sizeof(order));
    }
    
    Flow flow{"TestFlow", "Set1", Protocol{}, "", "", 0, 0, FlowDirection::INGRESS};
    auto timestamp = std::chrono::high_resolution_clock::now();
    
    auto messages = handler->getMessages(&flow, buffer.data(), buffer.size(), timestamp);
    
    ASSERT_EQ(messages.size(), 3);
}

// Test TCP message length calculation
TEST_F(RazeHandlerTest, CalculateTcpMessageLength) {
    RingBuffer buffer(1024);
    
    // Write a complete message
    RazeFormatter::NewOrder order;
    order.packet_length = sizeof(RazeFormatter::NewOrder);
    order.packet_type = RazeFormatter::PacketType::unsequenced_data;
    order.message_type = RazeFormatter::MessageType::new_order;
    
    buffer.write(reinterpret_cast<uint8_t*>(&order), sizeof(order));
    
    auto reader = buffer.getReader();
    EXPECT_EQ(handler->getTcpMessageLength(reader), sizeof(RazeFormatter::NewOrder));
}

// Test missing dropcopy entry
TEST_F(RazeHandlerTest, MissingDropcopyEntry) {
    // Don't add dropcopy entry for token 54321
    
    RazeFormatter::NewOrder order;
    order.packet_length = sizeof(RazeFormatter::NewOrder);
    order.packet_type = RazeFormatter::PacketType::unsequenced_data;
    order.message_type = RazeFormatter::MessageType::new_order;
    order.data.order_token = 54321;  // No dropcopy entry for this
    
    Flow flow{"TestFlow", "Set1", Protocol{}, "", "", 0, 0, FlowDirection::INGRESS};
    auto timestamp = std::chrono::high_resolution_clock::now();
    
    auto messages = handler->getMessages(&flow, reinterpret_cast<uint8_t*>(&order), 
                                        sizeof(order), timestamp);
    
    EXPECT_TRUE(messages.empty());
}

} // namespace pme 






















#include <gtest/gtest.h>
#include "RingBuffer.h"
#include <cstring>

namespace pme {

class RingBufferTest : public ::testing::Test {
protected:
    static constexpr size_t BUFFER_SIZE = 1024;
};

// Test basic write and read
TEST_F(RingBufferTest, WriteAndRead) {
    RingBuffer buffer(BUFFER_SIZE);
    
    // Write some data
    const char* data = "Hello, World!";
    size_t data_len = strlen(data);
    
    EXPECT_EQ(buffer.write(reinterpret_cast<const uint8_t*>(data), data_len), data_len);
    EXPECT_EQ(buffer.size(), data_len);
    
    // Read it back
    std::vector<uint8_t> read_data(data_len);
    auto reader = buffer.getReader();
    EXPECT_EQ(reader.read(read_data.data(), data_len), data_len);
    
    // Verify data matches
    EXPECT_EQ(memcmp(data, read_data.data(), data_len), 0);
}

// Test multiple writes and reads
TEST_F(RingBufferTest, MultipleWritesAndReads) {
    RingBuffer buffer(BUFFER_SIZE);
    
    // Write three messages
    const char* msg1 = "First message";
    const char* msg2 = "Second message";
    const char* msg3 = "Third message";
    
    buffer.write(reinterpret_cast<const uint8_t*>(msg1), strlen(msg1));
    buffer.write(reinterpret_cast<const uint8_t*>(msg2), strlen(msg2));
    buffer.write(reinterpret_cast<const uint8_t*>(msg3), strlen(msg3));
    
    // Read all back at once
    size_t total_size = strlen(msg1) + strlen(msg2) + strlen(msg3);
    std::vector<uint8_t> all_data(total_size);
    auto reader = buffer.getReader();
    EXPECT_EQ(reader.read(all_data.data(), total_size), total_size);
    
    // Verify all messages are there in order
    size_t offset = 0;
    EXPECT_EQ(memcmp(all_data.data() + offset, msg1, strlen(msg1)), 0);
    offset += strlen(msg1);
    EXPECT_EQ(memcmp(all_data.data() + offset, msg2, strlen(msg2)), 0);
    offset += strlen(msg2);
    EXPECT_EQ(memcmp(all_data.data() + offset, msg3, strlen(msg3)), 0);
}

// Test consume functionality
TEST_F(RingBufferTest, ConsumeData) {
    RingBuffer buffer(BUFFER_SIZE);
    
    // Write 100 bytes
    std::vector<uint8_t> data(100, 0xAA);
    buffer.write(data.data(), data.size());
    EXPECT_EQ(buffer.size(), 100);
    
    // Consume 50 bytes
    buffer.consume(50);
    EXPECT_EQ(buffer.size(), 50);
    
    // Read remaining 50 bytes
    std::vector<uint8_t> remaining(50);
    auto reader = buffer.getReader();
    EXPECT_EQ(reader.read(remaining.data(), 50), 50);
    
    // Should all be 0xAA
    for (uint8_t byte : remaining) {
        EXPECT_EQ(byte, 0xAA);
    }
}

// Test wrap-around behavior
TEST_F(RingBufferTest, WrapAround) {
    RingBuffer buffer(64);  // Small buffer to force wrap
    
    // Fill most of the buffer
    std::vector<uint8_t> data1(50, 0x11);
    buffer.write(data1.data(), data1.size());
    
    // Consume some to make room at the beginning
    buffer.consume(30);
    
    // Write more data that will wrap around
    std::vector<uint8_t> data2(40, 0x22);
    buffer.write(data2.data(), data2.size());
    
    // Read all data
    std::vector<uint8_t> all_data(60);  // 20 from data1 + 40 from data2
    auto reader = buffer.getReader();
    EXPECT_EQ(reader.read(all_data.data(), 60), 60);
    
    // Verify first 20 bytes are 0x11
    for (int i = 0; i < 20; i++) {
        EXPECT_EQ(all_data[i], 0x11);
    }
    // Verify next 40 bytes are 0x22
    for (int i = 20; i < 60; i++) {
        EXPECT_EQ(all_data[i], 0x22);
    }
}

// Test peek functionality
TEST_F(RingBufferTest, PeekData) {
    RingBuffer buffer(BUFFER_SIZE);
    
    // Write some data
    const char* data = "Test data for peeking";
    buffer.write(reinterpret_cast<const uint8_t*>(data), strlen(data));
    
    // Peek at first 4 bytes
    auto reader = buffer.getReader();
    uint32_t peeked_value;
    EXPECT_TRUE(reader.peek(reinterpret_cast<uint8_t*>(&peeked_value), sizeof(peeked_value)));
    
    // Verify buffer size hasn't changed
    EXPECT_EQ(buffer.size(), strlen(data));
    
    // Read normally and verify peek didn't consume
    std::vector<uint8_t> read_data(strlen(data));
    EXPECT_EQ(reader.read(read_data.data(), strlen(data)), strlen(data));
    EXPECT_EQ(memcmp(data, read_data.data(), strlen(data)), 0);
}

// Test buffer full condition
TEST_F(RingBufferTest, BufferFull) {
    RingBuffer buffer(64);
    
    // Fill the buffer completely
    std::vector<uint8_t> data(64, 0xFF);
    EXPECT_EQ(buffer.write(data.data(), data.size()), 64);
    
    // Try to write more - should fail
    uint8_t extra = 0xEE;
    EXPECT_EQ(buffer.write(&extra, 1), 0);
    
    // Consume one byte and try again
    buffer.consume(1);
    EXPECT_EQ(buffer.write(&extra, 1), 1);
}

} // namespace pme 
















#include <gtest/gtest.h>
#include "SpcastV3Handler.h"
#include <md_api/proto/spcast_v3.h>
#include "Types.h"
#include "Hash.h"
#include "Config.h"

namespace pme {

class SpcastV3HandlerTest : public ::testing::Test {
protected:
    AppConfig config;
    std::unique_ptr<SpcastV3Handler> handler;
    
    void SetUp() override {
        config.oldest_spcast_date = parseDateToHighResolutionClock("01/01/2020");
        handler = std::make_unique<SpcastV3Handler>(config);
    }
};

// Test parsing a real SpcastV3 packet with one message
TEST_F(SpcastV3HandlerTest, ParseSingleMessage) {
    // Create packet header + one message
    const uint16_t msg_size = sizeof(spcast::SpcastVersion3Traits::MessageHeader) + 8; // header + symbol
    std::vector<uint8_t> packet(sizeof(spcast::SpcastVersion3Traits::PacketHeader) + msg_size);
    
    // Fill packet header
    auto* pktHdr = reinterpret_cast<spcast::SpcastVersion3Traits::PacketHeader*>(packet.data());
    pktHdr->version = spcast::SpcastVersion3Traits::Version;
    pktHdr->recv_timestamp_ns = 1750000000000000000;
    pktHdr->send_timestamp_ns = 1750000000000000001;
    
    // Fill message header
    auto* msgHdr = reinterpret_cast<spcast::SpcastVersion3Traits::MessageHeader*>(
        packet.data() + sizeof(spcast::SpcastVersion3Traits::PacketHeader));
    msgHdr->length = msg_size;
    msgHdr->symbol_offset = sizeof(spcast::SpcastVersion3Traits::MessageHeader);
    msgHdr->symbol_size = 8;
    msgHdr->seq_num = 12345;
    msgHdr->exch_timestamp_ns = 1750000000000000000;
    
    Flow flow{"TestFlow", "Set1", Protocol{}, "", "", 0, 0, FlowDirection::INGRESS};
    auto timestamp = std::chrono::high_resolution_clock::now();
    
    auto messages = handler->getMessages(&flow, packet.data(), packet.size(), timestamp);
    
    ASSERT_EQ(messages.size(), 1);
    EXPECT_EQ(messages[0].join_key, generateHash(12345, 1750000000000000000, 1750000000000000001));
}

// Test duplicate detection - same sequence should be ignored
TEST_F(SpcastV3HandlerTest, SkipDuplicateSequence) {
    // Create same packet
    const uint16_t msg_size = sizeof(spcast::SpcastVersion3Traits::MessageHeader) + 8;
    std::vector<uint8_t> packet(sizeof(spcast::SpcastVersion3Traits::PacketHeader) + msg_size);
    
    auto* pktHdr = reinterpret_cast<spcast::SpcastVersion3Traits::PacketHeader*>(packet.data());
    pktHdr->version = spcast::SpcastVersion3Traits::Version;
    pktHdr->recv_timestamp_ns = 1750000000000000000;
    pktHdr->send_timestamp_ns = 1750000000000000001;
    
    auto* msgHdr = reinterpret_cast<spcast::SpcastVersion3Traits::MessageHeader*>(
        packet.data() + sizeof(spcast::SpcastVersion3Traits::PacketHeader));
    msgHdr->length = msg_size;
    msgHdr->symbol_offset = sizeof(spcast::SpcastVersion3Traits::MessageHeader);
    msgHdr->symbol_size = 8;
    msgHdr->seq_num = 99999;
    msgHdr->exch_timestamp_ns = 1750000000000000000;
    
    Flow flow{"TestFlow", "Set1", Protocol{}, "", "", 0, 0, FlowDirection::INGRESS};
    auto timestamp = std::chrono::high_resolution_clock::now();
    
    // First call processes
    auto messages1 = handler->getMessages(&flow, packet.data(), packet.size(), timestamp);
    ASSERT_EQ(messages1.size(), 1);
    
    // Second call with same sequence skips
    auto messages2 = handler->getMessages(&flow, packet.data(), packet.size(), timestamp);
    EXPECT_EQ(messages2.size(), 0);
}

// Test different flows track sequences independently
TEST_F(SpcastV3HandlerTest, FlowsAreIndependent) {
    const uint16_t msg_size = sizeof(spcast::SpcastVersion3Traits::MessageHeader) + 8;
    std::vector<uint8_t> packet(sizeof(spcast::SpcastVersion3Traits::PacketHeader) + msg_size);
    
    auto* pktHdr = reinterpret_cast<spcast::SpcastVersion3Traits::PacketHeader*>(packet.data());
    pktHdr->version = spcast::SpcastVersion3Traits::Version;
    pktHdr->recv_timestamp_ns = 1750000000000000000;
    pktHdr->send_timestamp_ns = 1750000000000000001;
    
    auto* msgHdr = reinterpret_cast<spcast::SpcastVersion3Traits::MessageHeader*>(
        packet.data() + sizeof(spcast::SpcastVersion3Traits::PacketHeader));
    msgHdr->length = msg_size;
    msgHdr->symbol_offset = sizeof(spcast::SpcastVersion3Traits::MessageHeader);
    msgHdr->symbol_size = 8;
    msgHdr->seq_num = 5000;
    msgHdr->exch_timestamp_ns = 1750000000000000000;
    
    Flow flow1{"Flow1", "Set1", Protocol{}, "", "", 0, 0, FlowDirection::INGRESS};
    Flow flow2{"Flow2", "Set1", Protocol{}, "", "", 0, 0, FlowDirection::INGRESS};
    auto timestamp = std::chrono::high_resolution_clock::now();
    
    // Same packet on different flows should both process
    auto messages1 = handler->getMessages(&flow1, packet.data(), packet.size(), timestamp);
    auto messages2 = handler->getMessages(&flow2, packet.data(), packet.size(), timestamp);
    
    EXPECT_EQ(messages1.size(), 1);
    EXPECT_EQ(messages2.size(), 1);
}

// Test invalid version is rejected
TEST_F(SpcastV3HandlerTest, RejectWrongVersion) {
    std::vector<uint8_t> packet(sizeof(spcast::SpcastVersion3Traits::PacketHeader));
    auto* pktHdr = reinterpret_cast<spcast::SpcastVersion3Traits::PacketHeader*>(packet.data());
    pktHdr->version = static_cast<md_api::proto::spcast_v3::version_enum>(1); // Wrong version
    
    Flow flow{"TestFlow", "Set1", Protocol{}, "", "", 0, 0, FlowDirection::INGRESS};
    auto timestamp = std::chrono::high_resolution_clock::now();
    
    auto messages = handler->getMessages(&flow, packet.data(), packet.size(), timestamp);
    EXPECT_TRUE(messages.empty());
}

// Test old timestamps are rejected
TEST_F(SpcastV3HandlerTest, RejectOldTimestamp) {
    const uint16_t msg_size = sizeof(spcast::SpcastVersion3Traits::MessageHeader) + 8;
    std::vector<uint8_t> packet(sizeof(spcast::SpcastVersion3Traits::PacketHeader) + msg_size);
    
    auto* pktHdr = reinterpret_cast<spcast::SpcastVersion3Traits::PacketHeader*>(packet.data());
    pktHdr->version = spcast::SpcastVersion3Traits::Version;
    pktHdr->recv_timestamp_ns = 1000000000000000000; // Year 2001
    pktHdr->send_timestamp_ns = 1000000000000000000;
    
    auto* msgHdr = reinterpret_cast<spcast::SpcastVersion3Traits::MessageHeader*>(
        packet.data() + sizeof(spcast::SpcastVersion3Traits::PacketHeader));
    msgHdr->length = msg_size;
    msgHdr->seq_num = 7777;
    
    Flow flow{"TestFlow", "Set1", Protocol{}, "", "", 0, 0, FlowDirection::INGRESS};
    auto timestamp = std::chrono::high_resolution_clock::now();
    
    auto messages = handler->getMessages(&flow, packet.data(), packet.size(), timestamp);
    EXPECT_TRUE(messages.empty());
}

} // namespace pme











#pragma once

#include <gtest/gtest.h>
#include <chrono>
#include <vector>
#include <cstring>

namespace pme::test {

// Simple timing helper for performance-sensitive tests
class TestTimer {
    using Clock = std::chrono::high_resolution_clock;
    Clock::time_point start_;
    
public:
    TestTimer() : start_(Clock::now()) {}
    
    double elapsedMs() const {
        auto elapsed = Clock::now() - start_;
        return std::chrono::duration<double, std::milli>(elapsed).count();
    }
    
    void reset() { start_ = Clock::now(); }
};

// Helper to create test data buffers
inline std::vector<uint8_t> makeTestData(size_t size, uint8_t fill_value = 0) {
    return std::vector<uint8_t>(size, fill_value);
}

// Helper to create test data with pattern
inline std::vector<uint8_t> makePatternData(size_t size) {
    std::vector<uint8_t> data(size);
    for (size_t i = 0; i < size; ++i) {
        data[i] = static_cast<uint8_t>(i & 0xFF);
    }
    return data;
}

// Common test timestamp
inline auto testTimestamp() {
    return std::chrono::high_resolution_clock::now();
}

// Convert string to bytes (useful for protocol testing)
inline std::vector<uint8_t> stringToBytes(const std::string& str) {
    return std::vector<uint8_t>(str.begin(), str.end());
}

// Helper to compare memory regions in tests
inline bool compareMemory(const void* ptr1, const void* ptr2, size_t size) {
    return std::memcmp(ptr1, ptr2, size) == 0;
}

// Simple RAII helper for test resources
template<typename Cleanup>
class ScopedCleanup {
    Cleanup cleanup_;
public:
    explicit ScopedCleanup(Cleanup cleanup) : cleanup_(std::move(cleanup)) {}
    ~ScopedCleanup() { cleanup_(); }
    
    ScopedCleanup(const ScopedCleanup&) = delete;
    ScopedCleanup& operator=(const ScopedCleanup&) = delete;
};

template<typename Cleanup>
auto makeCleanup(Cleanup cleanup) {
    return ScopedCleanup<Cleanup>(std::move(cleanup));
}

} // namespace pme::test 


