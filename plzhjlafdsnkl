#include "Config.h"

#include <filesystem>
#include <iostream>
#include <stdexcept>
#include <string>

#include <yaml-cpp/yaml.h>

#include "Protocols.h"

namespace pme {

Protocol parseProtocol(const YAML::Node& protocol_node) {
    if(!protocol_node["communication"] || !protocol_node["message"]) {
        throw std::runtime_error("Protocol definition must include 'communication' and 'message' fields");
    }

    Protocol protocol;
    std::string comm_str = protocol_node["communication"].as<std::string>();
    std::string msg_str = protocol_node["message"].as<std::string>();

    protocol.communication = stringToCommunicationProtocol(comm_str);
    protocol.message = stringToMessageProtocol(msg_str);

    if(!protocol.is_valid()) {
        throw std::runtime_error("Invalid protocol specified: " + comm_str + "/" + msg_str);
    }

    return protocol;
}

Flow parseFlow(const YAML::Node& node, FlowDirection direction, const std::string& parent_set) {
    Flow flow;
    flow.parent_set = parent_set;
    flow.direction = direction;
    if(!node["name"]) {
        throw std::runtime_error("Each flow must have a 'name' field");
    }

    if(node["name"]) {
        flow.name = node["name"].as<std::string>();
    }

    // Parse protocol
    if (!node["protocol"]) {
        throw std::runtime_error("Flow must have a 'protocol' field");
    }
    flow.protocol = parseProtocol(node["protocol"]);

    // Parse IP addresses
    if (node["src_ip"]) {
        flow.src_ip = node["src_ip"].as<std::string>();
    }
    if (node["dst_ip"]) {
        flow.dst_ip = node["dst_ip"].as<std::string>();
    }

    // Parse ports
    if (node["src_port"]) {
        flow.src_port = node["src_port"].as<uint16_t>();
    }
    if (node["dst_port"]) {
        flow.dst_port = node["dst_port"].as<uint16_t>();
    }

    return flow;
}

FlowSet parseFlowSet(const YAML::Node& node) {
    FlowSet flow_set;

    // Parse set name
    if (!node["set_name"]) {
        throw std::runtime_error("Flow set must have a 'set_name' field");
    }
    flow_set.set_name = node["set_name"].as<std::string>();

    // Parse ingress flows
    if (node["ingress_flows"]) {
        for (const auto& flow_node : node["ingress_flows"]) {
            flow_set.ingress_flows.push_back(
                parseFlow(flow_node, FlowDirection::INGRESS, flow_set.set_name)
            );
        }
    }

    // Parse egress flows
    if (node["egress_flows"]) {
        for (const auto& flow_node : node["egress_flows"]) {
            flow_set.egress_flows.push_back(
                parseFlow(flow_node, FlowDirection::EGRESS, flow_set.set_name)
            );
        }
    }

    // Parse directories
    if (node["watch_directory"]) {
        flow_set.watch_directory = node["watch_directory"].as<std::string>();
    }
    if (node["output_directory"]) {
        flow_set.output_directory = node["output_directory"].as<std::string>();
    }

    return flow_set;
}

AppConfig AppConfig::load(const std::string& config_path) {
    AppConfig config;

    try {
        // Check if file exists
        if (!std::filesystem::exists(config_path)) {
            throw std::runtime_error("Configuration file not found: " + config_path);
        }

        // Load YAML file
        YAML::Node root = YAML::LoadFile(config_path);

        // Parse flow sets
        if (root["flow_sets"]) {
            for (const auto& flow_set_node : root["flow_sets"]) {
                config.flow_sets.push_back(parseFlowSet(flow_set_node));
            }
        }

        // Parse other configs
        if (root["other_configs"]) {
            const auto& other = root["other_configs"];
            if (other["debug_mode"]) {
                config.debug_mode = other["debug_mode"].as<bool>();
            }
            if (other["dropcopy_path"]) {
                config.dropcopy_path = other["dropcopy_path"].as<std::string>();
            }
            if (other["oldest_spcast_date"]) {
                config.oldest_spcast_date = parseDateToHighResolutionClock(other["oldest_spcast_date"].as<std::string>());
            }
        }

        // Validate the loaded configuration
        config.validate();

    } catch (const YAML::Exception& e) {
        throw std::runtime_error("Failed to parse YAML configuration: " + std::string(e.what()));
    } catch (const std::exception& e) {
        throw std::runtime_error("Failed to load configuration: " + std::string(e.what()));
    }

    return config;
}

void AppConfig::validate() const {
    // Validate that we have at least one flow set
    if (flow_sets.empty()) {
        throw std::runtime_error("Configuration must define at least one flow set");
    }

    // Validate each flow set
    for (const auto& flow_set : flow_sets) {
        if (flow_set.set_name.empty()) {
            throw std::runtime_error("Flow set must have a non-empty name");
        }

        // Check that flow set has at least one flow
        if (flow_set.ingress_flows.empty() || flow_set.egress_flows.empty()) {
            throw std::runtime_error("Flow set '" + flow_set.set_name +
                                   "' must have at least one pair of ingress/egress flows");
        }

        // Validate each flow
        auto validate_flow = [&](const Flow& flow) {
            if (!flow.protocol.is_valid()) {
                throw std::runtime_error("Invalid protocol in flow for set '" +
                                       flow_set.set_name + "'");
            }
        };

        for (const auto& flow : flow_set.ingress_flows) {
            validate_flow(flow);
        }
        for (const auto& flow : flow_set.egress_flows) {
            validate_flow(flow);
        }
    }
}

} // namespace pme
