IPacketParser.h
cppCopy#pragma once

#include "PcapPacketIterator.h"
#include <cstdint>

/**
 * Interface for parsing packet data
 */
class IPacketParser {
public:
    virtual ~IPacketParser() = default;
    
    /**
     * Parse a packet
     * @param packetView View containing packet data
     * @return true if parsing was successful, false otherwise
     */
    virtual bool parse(const PcapPacketIterator::PacketView& packetView) = 0;
    
    /**
     * Reset parser state before starting a new file
     */
    virtual void reset() = 0;
};
PacketParser.h
cppCopy#pragma once

#include "IPacketParser.h"
#include "Log.h"
#include <cstdint>
#include <string>
#include <chrono>

/**
 * Parses raw packet data into structured format
 */
class PacketParser : public IPacketParser {
public:
    /**
     * Ethernet header structure (14 bytes)
     */
    struct EthernetHeader {
        uint8_t dstMac[6];   // Destination MAC address
        uint8_t srcMac[6];   // Source MAC address
        uint16_t etherType;  // EtherType field (IP, ARP, etc.)
    };
    
    /**
     * IPv4 header structure (minimum 20 bytes)
     */
    struct IPv4Header {
        uint8_t versionIhl;        // Version (4 bits) + Internet header length (4 bits)
        uint8_t typeOfService;     // Type of service
        uint16_t totalLength;      // Total length
        uint16_t identification;   // Identification
        uint16_t flagsFragmentOffset; // Flags (3 bits) + Fragment offset (13 bits)
        uint8_t ttl;              // Time to live
        uint8_t protocol;         // Protocol
        uint16_t headerChecksum;  // Header checksum
        uint32_t srcAddr;         // Source address
        uint32_t dstAddr;         // Destination address
        // Options (if IHL > 5)
    };
    
    /**
     * TCP header structure (minimum 20 bytes)
     */
    struct TCPHeader {
        uint16_t srcPort;        // Source port
        uint16_t dstPort;        // Destination port
        uint32_t seqNumber;      // Sequence number
        uint32_t ackNumber;      // Acknowledgment number
        uint16_t dataOffsetFlags; // Data offset (4 bits) + Reserved (3 bits) + Flags (9 bits)
        uint16_t window;         // Window
        uint16_t checksum;       // Checksum
        uint16_t urgentPointer;  // Urgent pointer
        // Options (if data offset > 5)
    };
    
    /**
     * UDP header structure (8 bytes)
     */
    struct UDPHeader {
        uint16_t srcPort;   // Source port
        uint16_t dstPort;   // Destination port
        uint16_t length;    // Length of UDP header and data
        uint16_t checksum;  // Checksum
    };
    
    /**
     * Constructor
     */
    PacketParser()
        : m_packetCount(0),
          log_(PME_GET_LOGGER("PacketParser")) {
        PME_LOG_INFO(log_, "PacketParser created");
    }
    
    /**
     * Parse a packet
     * @param packetView View containing packet data
     * @return true if parsing was successful, false otherwise
     */
    bool parse(const PcapPacketIterator::PacketView& packetView) override;
    
    /**
     * Reset parser state before starting a new file
     */
    void reset() override {
        m_packetCount = 0;
        PME_LOG_INFO(log_, "Parser state reset");
    }
    
    /**
     * Get number of packets parsed
     * @return Packet count
     */
    size_t getPacketCount() const {
        return m_packetCount;
    }
    
private:
    // Count of packets parsed
    size_t m_packetCount;
    
    // Logger
    px::Log* log_;
};
PacketParser.cpp
cppCopy#include "PacketParser.h"
#include <netinet/in.h>  // For ntohs, ntohl
#include <arpa/inet.h>   // For inet_ntoa

bool PacketParser::parse(const PcapPacketIterator::PacketView& packetView) {
    // Increment packet counter
    m_packetCount++;
    
    // Check if we have enough data for an Ethernet header
    if (packetView.dataSize < sizeof(EthernetHeader)) {
        PME_LOG_WARNING(log_, "Packet too small for Ethernet header: " << packetView.dataSize << " bytes");
        return false;
    }
    
    // Access packet contents - all pointers are direct into memory-mapped data
    const uint8_t* packetData = packetView.dataStart;
    const EthernetHeader* ethHeader = reinterpret_cast<const EthernetHeader*>(packetData);
    
    // Byte order conversion for etherType (assuming data is in network byte order)
    uint16_t etherType = ntohs(ethHeader->etherType);
    
    // Debug log for Ethernet header
    if (m_packetCount % 10000 == 0) {
        PME_LOG_DEBUG(log_, "Parsed packet " << m_packetCount 
                      << " with EtherType: 0x" << std::hex << etherType << std::dec);
    }
    
    // Here you would continue parsing based on etherType
    // For example, if etherType == 0x0800, it's an IPv4 packet
    // if etherType == 0x0806, it's an ARP packet
    
    // For now, we leave the actual parsing logic empty as requested
    
    return true;
}
Engine Integration
Now, let's integrate the PacketParser into the Engine class:
Engine.h modifications
cppCopy#pragma once

#include "IPcapFileHandler.h"
#include "IMMapHandler.h"
#include "ThreadSafeIterator.h"
#include "IPacketParser.h"
#include "Log.h"
#include <memory>
#include <string>
#include <atomic>
#include <chrono>

/**
 * Core engine that orchestrates the packet processing pipeline
 */
class Engine {
public:
    /**
     * Constructor
     * @param inputDir Directory containing PCAP files to process
     */
    Engine(const std::string& inputDir) 
        : m_inputDir(inputDir),
          m_shutdown(false),
          log_(PME_GET_LOGGER("Engine")) {
    }
    
    /**
     * Destructor
     */
    ~Engine() {
        stop();
    }
    
    /**
     * Initialize the engine components
     */
    void init();
    
    /**
     * Start the engine
     */
    void start();
    
    /**
     * Stop the engine
     */
    void stop();
    
    /**
     * Check if the engine should stop
     */
    bool shouldStop() const {
        return m_shutdown.load(std::memory_order_relaxed);
    }
    
    /**
     * Main engine loop
     */
    void run();
    
private:
    // Handle file transitions
    void onFileReady(const std::string& filePath);
    
    // Handle file processing completion
    void onFileProcessed();
    
    // Process packets from the current file
    void processCurrentFile();
    
    // Input directory
    std::string m_inputDir;
    
    // Components
    std::shared_ptr<IPcapFileHandler> m_fileHandler;
    std::shared_ptr<IMMapHandler> m_mmapHandler;
    std::unique_ptr<ThreadSafeIterator> m_iterator;
    std::unique_ptr<IPacketParser> m_parser;
    
    // State
    std::atomic<bool> m_shutdown;
    
    // Logger
    px::Log* log_;
};
Engine.cpp modifications
cppCopy#include "Engine.h"
#include "PcapFileHandler.h"
#include "MMapHandler.h"
#include "PacketParser.h"
#include <iostream>
#include <thread>

void Engine::init() {
    PME_LOG_INFO(log_, "Initializing engine with input directory: " << m_inputDir);
    
    // Create file handler
    m_fileHandler = std::make_shared<PcapFileHandler>(m_inputDir);
    
    // Create memory map handler
    m_mmapHandler = std::make_shared<MMapHandler>();
    
    // Create packet parser
    m_parser = std::make_unique<PacketParser>();
    
    // Set up callbacks
    m_fileHandler->setTransitionHandler([this](const std::string& filePath) {
        onFileReady(filePath);
    });
    
    m_mmapHandler->setCompletionHandler([this]() {
        onFileProcessed();
    });
    
    PME_LOG_INFO(log_, "Engine initialized");
}

void Engine::start() {
    PME_LOG_INFO(log_, "Starting engine");
    
    // Ensure components are initialized
    if (!m_fileHandler || !m_mmapHandler || !m_parser) {
        init();
    }
    
    // Start file processing
    static_cast<PcapFileHandler*>(m_fileHandler.get())->startProcessing();
    
    PME_LOG_INFO(log_, "Engine started");
}

void Engine::stop() {
    PME_LOG_INFO(log_, "Stopping engine");
    
    // Set shutdown flag
    m_shutdown.store(true, std::memory_order_relaxed);
    
    // Explicitly reset processed flag and unmap
    if (m_mmapHandler) {
        m_mmapHandler->resetProcessedFlag();
        m_mmapHandler->unmapCurrentFile();
    }
    
    // Clear iterator
    m_iterator.reset();
    
    PME_LOG_INFO(log_, "Engine stopped");
}

void Engine::onFileReady(const std::string& filePath) {
    PME_LOG_INFO(log_, "Processing file: " << filePath);
    
    // Reset parser state for new file
    m_parser->reset();
    
    // Map the file
    if (m_mmapHandler->processFile(filePath)) {
        // Create iterator over the mapped data
        m_iterator = std::make_unique<ThreadSafeIterator>(
            m_mmapHandler->getMappedData(),
            m_mmapHandler->getMappedSize()
        );
        
        PME_LOG_INFO(log_, "Created packet iterator for file: " << filePath);
    } else {
        PME_LOG_ERROR(log_, "Failed to process file: " << filePath);
        
        // Mark as processed and move to next
        m_fileHandler->markCurrentFileProcessed();
    }
}

void Engine::processCurrentFile() {
    // Get next packet
    PcapPacketIterator::PacketState state;
    PcapPacketIterator::PacketView view;
    
    std::tie(state, view) = m_iterator->next();
    
    switch (state) {
        case PcapPacketIterator::PacketState::VALID:
            // Parse the packet
            m_parser->parse(view);
            
            // Periodic logging
            if (static_cast<PacketParser*>(m_parser.get())->getPacketCount() % 10000 == 0) {
                PME_LOG_INFO(log_, "Parsed " << static_cast<PacketParser*>(m_parser.get())->getPacketCount() << " packets");
            }
            break;
            
        case PcapPacketIterator::PacketState::END_OF_FILE:
            PME_LOG_INFO(log_, "Reached end of file, parsed " 
                       << static_cast<PacketParser*>(m_parser.get())->getPacketCount() << " packets");
            
            // Mark the file as processed before unmapping
            m_mmapHandler->markCurrentFileProcessed();
            
            // Clean up
            m_mmapHandler->unmapCurrentFile();
            break;
            
        case PcapPacketIterator::PacketState::CORRUPT_HEADER:
        case PcapPacketIterator::PacketState::TRUNCATED:
        case PcapPacketIterator::PacketState::OUT_OF_BOUNDS:
            PME_LOG_WARNING(log_, "Encountered invalid packet with state: " 
                          << static_cast<int>(state));
            break;
    }
}

void Engine::onFileProcessed() {
    // Don't proceed if we're shutting down
    if (shouldStop()) {
        return;
    }
    
    PME_LOG_INFO(log_, "File processing complete");
    
    // Clear iterator
    m_iterator.reset();
    
    // Mark current file as processed and move to next
    m_fileHandler->markCurrentFileProcessed();
}

void Engine::run() {
    PME_LOG_INFO(log_, "Engine running");
    
    try {
        while (!shouldStop()) {
            // Process current file if we have one
            if (m_iterator) {
                processCurrentFile();
            } else {
                // No active file, sleep briefly to avoid busy-waiting
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
            }
        }
    } catch (const std::exception& e) {
        PME_LOG_FATAL(log_, "Exception in engine loop: " << e.what());
        stop();
    }
    
    PME_LOG_INFO(log_, "Engine run loop exited");
}
These changes integrate the PacketParser into the Engine, providing:

A structured way to access packet header information (Ethernet, IPv4, TCP, UDP)
A clean interface for parsing packet data
Integration into the existing Engine flow

The parser is called for each valid packet in the PCAP file. You can now implement the actual parsing logic in the parse() method according to your specific requirements, with full access to the raw packet data via the packetView parameter.
The packet headers are defined as structures that map directly to their binary representation in the packet data, making it easy to access fields. The actual parsing logic is left empty as requested, but the framework for accessing all packet data is in place.Add to Conversation
