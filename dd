# Complete Refactored Codebase

Here's the fully refactored codebase incorporating all suggested improvements. This codebase should compile as-is.

## 1. First, the Core Directory Watcher Interface and Implementation

### DirectoryWatcher.h
```cpp
#pragma once

#include <string>
#include <functional>
#include <memory>
#include <atomic>
#include <thread>
#include "Log.h"

/**
 * Event types reported by directory watcher
 */
enum class FileEventType {
    CREATED,  // File was created
    MODIFIED, // File was modified
    DELETED   // File was deleted
};

/**
 * Structure representing a file system event
 */
struct FileEvent {
    FileEventType type;      // Type of event
    std::string filePath;    // Full path to the file
    
    FileEvent(FileEventType t, const std::string& path) 
        : type(t), filePath(path) {}
};

/**
 * Interface for directory watching implementations
 */
class IDirectoryWatcher {
public:
    using EventCallback = std::function<void(const FileEvent&)>;
    
    virtual ~IDirectoryWatcher() = default;
    
    /**
     * Start watching a directory
     * 
     * @param callback Function to call when events occur
     * @return True if watching started successfully
     */
    virtual bool start(EventCallback callback) = 0;
    
    /**
     * Stop watching the directory
     */
    virtual void stop() = 0;
    
    /**
     * Check if watcher is currently running
     * 
     * @return True if running
     */
    virtual bool isRunning() const = 0;
};

/**
 * RAII wrapper for inotify file descriptor
 */
class InotifyHandle {
public:
    InotifyHandle();
    ~InotifyHandle();
    
    // Non-copyable
    InotifyHandle(const InotifyHandle&) = delete;
    InotifyHandle& operator=(const InotifyHandle&) = delete;
    
    /**
     * Get the inotify file descriptor
     * 
     * @return File descriptor or -1 if not initialized
     */
    int getFd() const { return m_fd; }
    
    /**
     * Add a watch for a directory
     * 
     * @param path Directory path to watch
     * @param mask Event mask
     * @return Watch descriptor or -1 on error
     */
    int addWatch(const std::string& path, uint32_t mask);
    
    /**
     * Remove a watch
     * 
     * @param watchFd Watch descriptor to remove
     * @return True if successful
     */
    bool removeWatch(int watchFd);
    
    /**
     * Check if handle is valid
     * 
     * @return True if valid
     */
    bool isValid() const { return m_fd >= 0; }
    
private:
    int m_fd;
};

/**
 * Linux-specific directory watcher using inotify
 */
class InotifyDirectoryWatcher : public IDirectoryWatcher {
public:
    /**
     * Create a watcher for a directory
     * 
     * @param directory Path to directory to watch
     * @param recursive Whether to watch subdirectories
     */
    InotifyDirectoryWatcher(const std::string& directory, bool recursive = false);
    
    /**
     * Destructor ensures watcher is stopped
     */
    ~InotifyDirectoryWatcher() override;
    
    // Implementation of IDirectoryWatcher interface
    bool start(EventCallback callback) override;
    void stop() override;
    bool isRunning() const override;
    
private:
    /**
     * Main watching thread function
     */
    void watchThread();
    
    /**
     * Process inotify events from buffer
     * 
     * @param buffer Buffer containing events
     * @param length Length of buffer
     */
    void processEvents(const char* buffer, int length);
    
    /**
     * Add watches for all subdirectories
     * 
     * @param path Base directory path
     * @return True if successful
     */
    bool addWatchesRecursively(const std::string& path);
    
    std::string m_directory;
    bool m_recursive;
    std::atomic<bool> m_running;
    EventCallback m_callback;
    
    InotifyHandle m_inotify;
    int m_watchFd;
    
    std::thread m_thread;
    px::Log* log_;
};
```

### DirectoryWatcher.cpp
```cpp
#include "DirectoryWatcher.h"
#include <sys/inotify.h>
#include <unistd.h>
#include <fcntl.h>
#include <poll.h>
#include <string.h>
#include <limits.h>
#include <filesystem>
#include <stdexcept>

namespace fs = std::filesystem;

// Size of buffer for inotify events
#define EVENT_BUF_LEN (10 * (sizeof(struct inotify_event) + NAME_MAX + 1))

// ----- InotifyHandle implementation -----

InotifyHandle::InotifyHandle() : m_fd(-1) {
    m_fd = inotify_init1(IN_NONBLOCK);
}

InotifyHandle::~InotifyHandle() {
    if (m_fd >= 0) {
        close(m_fd);
        m_fd = -1;
    }
}

int InotifyHandle::addWatch(const std::string& path, uint32_t mask) {
    if (m_fd < 0) {
        return -1;
    }
    return inotify_add_watch(m_fd, path.c_str(), mask);
}

bool InotifyHandle::removeWatch(int watchFd) {
    if (m_fd < 0 || watchFd < 0) {
        return false;
    }
    return inotify_rm_watch(m_fd, watchFd) == 0;
}

// ----- InotifyDirectoryWatcher implementation -----

InotifyDirectoryWatcher::InotifyDirectoryWatcher(const std::string& directory, bool recursive)
    : m_directory(directory),
      m_recursive(recursive),
      m_running(false),
      m_watchFd(-1),
      log_(PME_GET_LOGGER("InotifyDirectoryWatcher"))
{
    if (!fs::exists(directory)) {
        throw std::runtime_error("Directory does not exist: " + directory);
    }
    
    if (!fs::is_directory(directory)) {
        throw std::runtime_error("Path is not a directory: " + directory);
    }
}

InotifyDirectoryWatcher::~InotifyDirectoryWatcher() {
    stop();
}

bool InotifyDirectoryWatcher::start(EventCallback callback) {
    if (m_running.load(std::memory_order_relaxed)) {
        return true; // Already running
    }
    
    if (!callback) {
        PME_LOG_ERROR(log_, "Cannot start with null callback");
        return false;
    }
    
    m_callback = callback;
    
    // Check if inotify is valid
    if (!m_inotify.isValid()) {
        PME_LOG_ERROR(log_, "Failed to initialize inotify");
        return false;
    }
    
    // Add watch for the directory
    uint32_t mask = IN_CREATE | IN_MODIFY | IN_DELETE | IN_MOVED_TO | IN_MOVED_FROM;
    m_watchFd = m_inotify.addWatch(m_directory, mask);
    
    if (m_watchFd < 0) {
        PME_LOG_ERROR(log_, "Failed to add watch for directory: " << strerror(errno));
        return false;
    }
    
    // Add watches for subdirectories if requested
    if (m_recursive && !addWatchesRecursively(m_directory)) {
        PME_LOG_WARNING(log_, "Failed to add watches for some subdirectories");
        // Continue anyway with the directories we could watch
    }
    
    // Start watching thread
    m_running.store(true, std::memory_order_relaxed);
    
    try {
        m_thread = std::thread(&InotifyDirectoryWatcher::watchThread, this);
        PME_LOG_INFO(log_, "Directory watcher started for: " << m_directory);
        return true;
    } catch (const std::exception& e) {
        m_running.store(false, std::memory_order_relaxed);
        m_inotify.removeWatch(m_watchFd);
        m_watchFd = -1;
        PME_LOG_ERROR(log_, "Failed to start watch thread: " << e.what());
        return false;
    }
}

void InotifyDirectoryWatcher::stop() {
    if (!m_running.load(std::memory_order_relaxed)) {
        return; // Already stopped
    }
    
    // Signal thread to stop
    m_running.store(false, std::memory_order_relaxed);
    
    // Clean up watch
    if (m_watchFd >= 0) {
        m_inotify.removeWatch(m_watchFd);
        m_watchFd = -1;
    }
    
    // Join thread
    if (m_thread.joinable()) {
        m_thread.join();
    }
    
    PME_LOG_INFO(log_, "Directory watcher stopped");
}

bool InotifyDirectoryWatcher::isRunning() const {
    return m_running.load(std::memory_order_relaxed);
}

void InotifyDirectoryWatcher::watchThread() {
    char buffer[EVENT_BUF_LEN];
    struct pollfd pfd;
    
    pfd.fd = m_inotify.getFd();
    pfd.events = POLLIN;
    
    PME_LOG_INFO(log_, "Watch thread started");
    
    try {
        while (m_running.load(std::memory_order_relaxed)) {
            // Wait for events with a timeout
            int ret = poll(&pfd, 1, 500); // 500ms timeout
            
            if (ret < 0) {
                // Poll error
                if (errno != EINTR) {
                    PME_LOG_ERROR(log_, "Poll error: " << strerror(errno));
                    break;
                }
                continue;
            }
            
            if (ret == 0) {
                // Timeout, check if we should continue running
                continue;
            }
            
            if (pfd.revents & POLLIN) {
                // Read inotify events
                int length = read(m_inotify.getFd(), buffer, EVENT_BUF_LEN);
                
                if (length < 0) {
                    if (errno != EAGAIN) {
                        PME_LOG_ERROR(log_, "Error reading inotify events: " << strerror(errno));
                        break;
                    }
                    continue;
                }
                
                // Process events
                if (length > 0) {
                    processEvents(buffer, length);
                }
            }
        }
    } catch (const std::exception& e) {
        PME_LOG_ERROR(log_, "Exception in watch thread: " << e.what());
    }
    
    PME_LOG_INFO(log_, "Watch thread exiting");
}

void InotifyDirectoryWatcher::processEvents(const char* buffer, int length) {
    int i = 0;
    while (i < length) {
        struct inotify_event* event = (struct inotify_event*)&buffer[i];
        
        if (event->len) {
            std::string fileName = event->name;
            std::string filePath = m_directory + "/" + fileName;
            
            try {
                if (event->mask & (IN_CREATE | IN_MOVED_TO)) {
                    // New file or directory
                    m_callback(FileEvent(FileEventType::CREATED, filePath));
                    
                    // If this is a new directory and we're watching recursively, add a watch
                    if (m_recursive && (event->mask & IN_ISDIR)) {
                        uint32_t mask = IN_CREATE | IN_MODIFY | IN_DELETE | IN_MOVED_TO | IN_MOVED_FROM;
                        m_inotify.addWatch(filePath, mask);
                    }
                }
                else if (event->mask & IN_MODIFY) {
                    m_callback(FileEvent(FileEventType::MODIFIED, filePath));
                }
                else if (event->mask & (IN_DELETE | IN_MOVED_FROM)) {
                    m_callback(FileEvent(FileEventType::DELETED, filePath));
                }
            } catch (const std::exception& e) {
                PME_LOG_ERROR(log_, "Error processing event for " << filePath << ": " << e.what());
            }
        }
        
        i += sizeof(struct inotify_event) + event->len;
    }
}

bool InotifyDirectoryWatcher::addWatchesRecursively(const std::string& path) {
    bool success = true;
    
    try {
        for (const auto& entry : fs::recursive_directory_iterator(path)) {
            if (entry.is_directory()) {
                uint32_t mask = IN_CREATE | IN_MODIFY | IN_DELETE | IN_MOVED_TO | IN_MOVED_FROM;
                int wd = m_inotify.addWatch(entry.path().string(), mask);
                
                if (wd < 0) {
                    PME_LOG_WARNING(log_, "Failed to add watch for " << entry.path().string());
                    success = false;
                }
            }
        }
    } catch (const std::exception& e) {
        PME_LOG_ERROR(log_, "Exception adding recursive watches: " << e.what());
        success = false;
    }
    
    return success;
}
```

## 2. File State Management

### FileRecord.h
```cpp
#pragma once

#include <string>
#include <cstdint>
#include <ctime>
#include <mutex>
#include <filesystem>

/**
 * File processing states
 */
enum class FileState {
    INVALID,            // File is not a valid PCAP file
    GROWING,            // File is actively being written to
    UNPROCESSED_STATIC, // File is complete but hasn't been processed
    PROCESSED_STATIC    // File has been processed
};

/**
 * Thread-safe record of a file's state and metadata
 */
class FileRecord {
public:
    /**
     * Create a new file record
     * 
     * @param state Initial state
     * @param size Initial size
     */
    FileRecord(FileState state = FileState::INVALID, std::uintmax_t size = 0);
    
    /**
     * Get the current state
     * 
     * @return File state
     */
    FileState getState() const;
    
    /**
     * Set the file state
     * 
     * @param state New state
     */
    void setState(FileState state);
    
    /**
     * Get the file size
     * 
     * @return Current size in bytes
     */
    std::uintmax_t getSize() const;
    
    /**
     * Update the file size
     * 
     * @param size New size in bytes
     * @return True if size changed
     */
    bool updateSize(std::uintmax_t size);
    
    /**
     * Get the last modified timestamp
     * 
     * @return Timestamp
     */
    std::time_t getTimestamp() const;
    
    /**
     * Update the timestamp
     * 
     * @param timestamp New timestamp
     */
    void updateTimestamp(std::time_t timestamp);
    
    /**
     * Check if file has grown since last check
     * 
     * @param currentSize Current file size
     * @return True if grown
     */
    bool hasGrown(std::uintmax_t currentSize);
    
    /**
     * Reset the growth check counter
     */
    void resetGrowthChecks();
    
    /**
     * Increment the failed growth check counter
     * 
     * @return Current count of consecutive failed checks
     */
    int incrementFailedGrowthChecks();
    
    /**
     * Get count of consecutive failed growth checks
     * 
     * @return Count of failed checks
     */
    int getFailedGrowthChecks() const;
    
private:
    mutable std::mutex m_mutex;
    FileState m_state;
    std::uintmax_t m_size;
    std::time_t m_timestamp;
    int m_failedGrowthChecks;
};
```

### FileRecord.cpp
```cpp
#include "FileRecord.h"

FileRecord::FileRecord(FileState state, std::uintmax_t size)
    : m_state(state), 
      m_size(size),
      m_timestamp(std::time(nullptr)),
      m_failedGrowthChecks(0)
{
}

FileState FileRecord::getState() const {
    std::lock_guard<std::mutex> lock(m_mutex);
    return m_state;
}

void FileRecord::setState(FileState state) {
    std::lock_guard<std::mutex> lock(m_mutex);
    m_state = state;
}

std::uintmax_t FileRecord::getSize() const {
    std::lock_guard<std::mutex> lock(m_mutex);
    return m_size;
}

bool FileRecord::updateSize(std::uintmax_t size) {
    std::lock_guard<std::mutex> lock(m_mutex);
    bool changed = (size != m_size);
    m_size = size;
    return changed;
}

std::time_t FileRecord::getTimestamp() const {
    std::lock_guard<std::mutex> lock(m_mutex);
    return m_timestamp;
}

void FileRecord::updateTimestamp(std::time_t timestamp) {
    std::lock_guard<std::mutex> lock(m_mutex);
    m_timestamp = timestamp;
}

bool FileRecord::hasGrown(std::uintmax_t currentSize) {
    std::lock_guard<std::mutex> lock(m_mutex);
    bool hasGrown = (currentSize > m_size);
    m_size = currentSize;
    
    if (hasGrown) {
        m_failedGrowthChecks = 0;
    }
    
    return hasGrown;
}

void FileRecord::resetGrowthChecks() {
    std::lock_guard<std::mutex> lock(m_mutex);
    m_failedGrowthChecks = 0;
}

int FileRecord::incrementFailedGrowthChecks() {
    std::lock_guard<std::mutex> lock(m_mutex);
    return ++m_failedGrowthChecks;
}

int FileRecord::getFailedGrowthChecks() const {
    std::lock_guard<std::mutex> lock(m_mutex);
    return m_failedGrowthChecks;
}
```

## 3. File State Manager

### FileStateManager.h
```cpp
#pragma once

#include "FileRecord.h"
#include "Log.h"
#include <string>
#include <unordered_map>
#include <mutex>
#include <functional>
#include <optional>

/**
 * Interface for strategies to detect if a file is growing
 */
class IGrowthDetector {
public:
    virtual ~IGrowthDetector() = default;
    
    /**
     * Check if a file is growing
     * 
     * @param filePath Path to the file
     * @param record Current file record
     * @return True if the file is growing
     */
    virtual bool isGrowing(const std::string& filePath, FileRecord& record) = 0;
    
    /**
     * Check if a file has stopped growing
     * 
     * @param filePath Path to the file
     * @param record Current file record
     * @param maxChecks Maximum number of checks before deciding growth stopped
     * @return True if the file has stopped growing
     */
    virtual bool hasStoppedGrowing(const std::string& filePath, FileRecord& record, int maxChecks) = 0;
};

/**
 * Strategy that detects growth by comparing file sizes
 */
class SizeProbeGrowthDetector : public IGrowthDetector {
public:
    bool isGrowing(const std::string& filePath, FileRecord& record) override;
    bool hasStoppedGrowing(const std::string& filePath, FileRecord& record, int maxChecks) override;
};

/**
 * Manages the state of files in a directory
 */
class FileStateManager {
public:
    /**
     * Create a file state manager
     * 
     * @param growthDetector Strategy to detect file growth
     * @param maxGrowthChecks Maximum consecutive checks before deciding growth stopped
     */
    FileStateManager(std::unique_ptr<IGrowthDetector> growthDetector, int maxGrowthChecks = 3);
    
    /**
     * Process a file creation event
     * 
     * @param filePath Path to the file
     * @return True if file is valid and added
     */
    bool onFileCreated(const std::string& filePath);
    
    /**
     * Process a file modification event
     * 
     * @param filePath Path to the file
     * @return True if file state changed
     */
    bool onFileModified(const std::string& filePath);
    
    /**
     * Process a file deletion event
     * 
     * @param filePath Path to the file
     * @return True if file was being tracked
     */
    bool onFileDeleted(const std::string& filePath);
    
    /**
     * Check for files that have stopped growing
     * 
     * @return List of files that have stopped growing
     */
    std::vector<std::string> checkStoppedGrowing();
    
    /**
     * Get the current state of a file
     * 
     * @param filePath Path to the file
     * @return File state or INVALID if not found
     */
    FileState getFileState(const std::string& filePath) const;
    
    /**
     * Mark a file as processed
     * 
     * @param filePath Path to the file
     * @return True if file was found and marked
     */
    bool markFileProcessed(const std::string& filePath);
    
    /**
     * Check if a file exists in our tracking
     * 
     * @param filePath Path to check
     * @return True if file is being tracked
     */
    bool hasFile(const std::string& filePath) const;
    
    /**
     * Get the timestamp of a file
     * 
     * @param filePath Path to the file
     * @return Timestamp or 0 if not found
     */
    std::time_t getFileTimestamp(const std::string& filePath) const;
    
    /**
     * Check if a file is valid (based on PCAP header)
     * 
     * @param filePath Path to check
     * @return True if file is a valid PCAP
     */
    static bool isValidPcapFile(const std::string& filePath);
    
    /**
     * Get all files in a specific state
     * 
     * @param state State to filter by
     * @return Vector of file paths
     */
    std::vector<std::string> getFilesInState(FileState state) const;
    
    /**
     * Get count of files in a specific state
     * 
     * @param state State to count
     * @return Count of files
     */
    int getFileCount(FileState state) const;
    
private:
    std::unique_ptr<IGrowthDetector> m_growthDetector;
    int m_maxGrowthChecks;
    
    mutable std::mutex m_mutex;
    std::unordered_map<std::string, FileRecord> m_files;
    
    px::Log* log_;
};
```

### FileStateManager.cpp
```cpp
#include "FileStateManager.h"
#include <filesystem>
#include <fcntl.h>
#include <unistd.h>
#include <thread>
#include <chrono>

namespace fs = std::filesystem;

// ----- SizeProbeGrowthDetector implementation -----

bool SizeProbeGrowthDetector::isGrowing(const std::string& filePath, FileRecord& record) {
    try {
        if (!fs::exists(filePath)) {
            return false;
        }
        
        auto currentSize = fs::file_size(filePath);
        return record.hasGrown(currentSize);
    } catch (const std::exception&) {
        return false;
    }
}

bool SizeProbeGrowthDetector::hasStoppedGrowing(const std::string& filePath, FileRecord& record, int maxChecks) {
    try {
        if (!fs::exists(filePath)) {
            return true; // File doesn't exist, so it's not growing
        }
        
        auto currentSize = fs::file_size(filePath);
        if (record.hasGrown(currentSize)) {
            return false; // Size increased, still growing
        }
        
        // Size didn't change, increment failed check counter
        int failedChecks = record.incrementFailedGrowthChecks();
        return failedChecks >= maxChecks;
    } catch (const std::exception&) {
        return true; // Error accessing file, assume it stopped growing
    }
}

// ----- FileStateManager implementation -----

FileStateManager::FileStateManager(std::unique_ptr<IGrowthDetector> growthDetector, int maxGrowthChecks)
    : m_growthDetector(std::move(growthDetector)),
      m_maxGrowthChecks(maxGrowthChecks),
      log_(PME_GET_LOGGER("FileStateManager"))
{
    if (!m_growthDetector) {
        // Default to size probe if none provided
        m_growthDetector = std::make_unique<SizeProbeGrowthDetector>();
    }
}

bool FileStateManager::onFileCreated(const std::string& filePath) {
    if (!fs::exists(filePath) || !fs::is_regular_file(filePath)) {
        return false;
    }
    
    std::lock_guard<std::mutex> lock(m_mutex);
    
    // Check if already tracking
    if (m_files.find(filePath) != m_files.end()) {
        return false;
    }
    
    // Check if valid PCAP
    if (!isValidPcapFile(filePath)) {
        m_files.emplace(filePath, FileRecord(FileState::INVALID, 0));
        return false;
    }
    
    // Get current size and timestamp
    std::uintmax_t size = fs::file_size(filePath);
    std::time_t timestamp = fs::last_write_time(filePath).time_since_epoch().count();
    
    // Create record
    FileRecord record(FileState::UNPROCESSED_STATIC, size);
    record.updateTimestamp(timestamp);
    
    // Check if growing
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    if (m_growthDetector->isGrowing(filePath, record)) {
        record.setState(FileState::GROWING);
    }
    
    // Add to tracking
    m_files.emplace(filePath, std::move(record));
    
    PME_LOG_INFO(log_, "Added new file: " << filePath << " with state " << 
                 (m_files[filePath].getState() == FileState::GROWING ? "GROWING" : "UNPROCESSED_STATIC"));
    
    return true;
}

bool FileStateManager::onFileModified(const std::string& filePath) {
    if (!fs::exists(filePath)) {
        return false;
    }
    
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto it = m_files.find(filePath);
    if (it == m_files.end()) {
        return false;
    }
    
    FileRecord& record = it->second;
    bool stateChanged = false;
    
    // Update size
    try {
        record.updateSize(fs::file_size(filePath));
    } catch (const std::exception&) {
        // Ignore size update errors
    }
    
    // If file was invalid, check if it's valid now
    if (record.getState() == FileState::INVALID && isValidPcapFile(filePath)) {
        record.setState(FileState::UNPROCESSED_STATIC);
        stateChanged = true;
        PME_LOG_INFO(log_, "Previously invalid file is now valid: " << filePath);
    }
    
    return stateChanged;
}

bool FileStateManager::onFileDeleted(const std::string& filePath) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto it = m_files.find(filePath);
    if (it != m_files.end()) {
        PME_LOG_INFO(log_, "Removed deleted file: " << filePath);
        m_files.erase(it);
        return true;
    }
    
    return false;
}

std::vector<std::string> FileStateManager::checkStoppedGrowing() {
    std::vector<std::string> stoppedFiles;
    std::lock_guard<std::mutex> lock(m_mutex);
    
    for (auto& [filePath, record] : m_files) {
        if (record.getState() == FileState::GROWING && 
            m_growthDetector->hasStoppedGrowing(filePath, record, m_maxGrowthChecks)) {
            
            record.setState(FileState::UNPROCESSED_STATIC);
            stoppedFiles.push_back(filePath);
            PME_LOG_INFO(log_, "File stopped growing: " << filePath);
        }
    }
    
    return stoppedFiles;
}

FileState FileStateManager::getFileState(const std::string& filePath) const {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto it = m_files.find(filePath);
    if (it != m_files.end()) {
        return it->second.getState();
    }
    
    return FileState::INVALID;
}

bool FileStateManager::markFileProcessed(const std::string& filePath) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto it = m_files.find(filePath);
    if (it != m_files.end()) {
        it->second.setState(FileState::PROCESSED_STATIC);
        PME_LOG_INFO(log_, "Marked file as processed: " << filePath);
        return true;
    }
    
    return false;
}

bool FileStateManager::hasFile(const std::string& filePath) const {
    std::lock_guard<std::mutex> lock(m_mutex);
    return m_files.find(filePath) != m_files.end();
}

std::time_t FileStateManager::getFileTimestamp(const std::string& filePath) const {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto it = m_files.find(filePath);
    if (it != m_files.end()) {
        return it->second.getTimestamp();
    }
    
    return 0;
}

bool FileStateManager::isValidPcapFile(const std::string& filePath) {
    if (!fs::exists(filePath)) {
        return false;
    }
    
    try {
        if (fs::file_size(filePath) < 24) {
            return false;
        }
    } catch (const std::exception&) {
        return false;
    }
    
    // Open the file to check its header
    int fd = open(filePath.c_str(), O_RDONLY);
    if (fd == -1) {
        return false;
    }
    
    // Read the PCAP global header (24 bytes)
    uint8_t header[24];
    ssize_t bytesRead = read(fd, header, sizeof(header));
    close(fd);
    
    if (bytesRead != sizeof(header)) {
        return false;
    }
    
    // Check magic number (0xa1b2c3d4 or 0xd4c3b2a1)
    uint32_t magic = *reinterpret_cast<uint32_t*>(header);
    return (magic == 0xa1b2c3d4 || magic == 0xd4c3b2a1);
}

std::vector<std::string> FileStateManager::getFilesInState(FileState state) const {
    std::vector<std::string> result;
    std::lock_guard<std::mutex> lock(m_mutex);
    
    for (const auto& [filePath, record] : m_files) {
        if (record.getState() == state) {
            result.push_back(filePath);
        }
    }
    
    return result;
}

int FileStateManager::getFileCount(FileState state) const {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    int count = 0;
    for (const auto& [filePath, record] : m_files) {
        if (record.getState() == state) {
            count++;
        }
    }
    
    return count;
}
```

## 4. Processing Queue

### ProcessingQueue.h
```cpp
#pragma once

#include "FileRecord.h"
#include "Log.h"
#include <string>
#include <vector>
#include <mutex>
#include <condition_variable>
#include <functional>
#include <optional>
#include <algorithm>

/**
 * Thread-safe queue of files to process.
 * Files are maintained in priority order (by timestamp).
 */
class ProcessingQueue {
public:
    /**
     * Create a processing queue
     */
    ProcessingQueue();
    
    /**
     * Add a file to the queue
     * 
     * @param filePath Path to the file
     * @param timestamp Timestamp for sorting
     * @param isExistingFile If true, check for duplicates before adding
     * @return True if added
     */
    bool addFile(const std::string& filePath, std::time_t timestamp, bool isExistingFile = false);
    
    /**
     * Remove a file from the queue
     * 
     * @param filePath Path to remove
     * @return True if found and removed
     */
    bool removeFile(const std::string& filePath);
    
    /**
     * Get the next file that satisfies a condition
     * 
     * @param predicate Function that tests if a file should be selected
     * @return Path to selected file or empty optional
     */
    std::optional<std::string> getNextFile(std::function<bool(const std::string&)> predicate);
    
    /**
     * Wait for a file that satisfies a condition
     * 
     * @param predicate Function that tests if a file should be selected
     * @param timeoutMs Maximum time to wait (0 = wait forever)
     * @return Path to selected file or empty optional on timeout
     */
    std::optional<std::string> waitForFile(
        std::function<bool(const std::string&)> predicate,
        unsigned int timeoutMs = 0);
    
    /**
     * Check if the queue is empty
     * 
     * @return True if empty
     */
    bool isEmpty() const;
    
    /**
     * Get the number of files in the queue
     * 
     * @return File count
     */
    size_t size() const;
    
    /**
     * Clear all files from the queue
     */
    void clear();
    
    /**
     * Signal any waiting threads that the queue state has changed
     */
    void signal();
    
private:
    /**
     * File entry with timestamp for ordering
     */
    struct FileEntry {
        std::string filePath;
        std::time_t timestamp;
        
        FileEntry(const std::string& path, std::time_t time)
            : filePath(path), timestamp(time) {}
        
        bool operator<(const FileEntry& other) const {
            return timestamp < other.timestamp;
        }
    };
    
    mutable std::mutex m_mutex;
    std::condition_variable m_condition;
    std::vector<FileEntry> m_queue;
    
    px::Log* log_;
};
```

### ProcessingQueue.cpp
```cpp
#include "ProcessingQueue.h"

ProcessingQueue::ProcessingQueue()
    : log_(PME_GET_LOGGER("ProcessingQueue"))
{
}

bool ProcessingQueue::addFile(const std::string& filePath, std::time_t timestamp, bool isExistingFile) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    // Check if file already in queue
    if (isExistingFile) {
        auto it = std::find_if(m_queue.begin(), m_queue.end(),
            [&](const auto& entry) { return entry.filePath == filePath; });
        
        if (it != m_queue.end()) {
            return false;
        }
    }
    
    // Find sorted position
    auto insertPos = std::lower_bound(m_queue.begin(), m_queue.end(), 
        FileEntry(filePath, timestamp));
    
    // Insert at position
    m_queue.insert(insertPos, FileEntry(filePath, timestamp));
    
    // Signal waiting threads
    m_condition.notify_all();
    
    PME_LOG_INFO(log_, "Added file to queue: " << filePath);
    return true;
}

bool ProcessingQueue::removeFile(const std::string& filePath) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto it = std::find_if(m_queue.begin(), m_queue.end(),
        [&](const auto& entry) { return entry.filePath == filePath; });
    
    if (it != m_queue.end()) {
        m_queue.erase(it);
        PME_LOG_INFO(log_, "Removed file from queue: " << filePath);
        return true;
    }
    
    return false;
}

std::optional<std::string> ProcessingQueue::getNextFile(std::function<bool(const std::string&)> predicate) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    for (const auto& entry : m_queue) {
        if (predicate(entry.filePath)) {
            return entry.filePath;
        }
    }
    
    return std::nullopt;
}

std::optional<std::string> ProcessingQueue::waitForFile(
    std::function<bool(const std::string&)> predicate,
    unsigned int timeoutMs)
{
    std::unique_lock<std::mutex> lock(m_mutex);
    
    // Check if a file is already available
    for (const auto& entry : m_queue) {
        if (predicate(entry.filePath)) {
            return entry.filePath;
        }
    }
    
    // Wait for a file to become available
    auto hasFile = [this, &predicate]() -> bool {
        for (const auto& entry : m_queue) {
            if (predicate(entry.filePath)) {
                return true;
            }
        }
        return false;
    };
    
    if (timeoutMs == 0) {
        // Wait indefinitely
        m_condition.wait(lock, hasFile);
    } else {
        // Wait with timeout
        if (!m_condition.wait_for(lock, std::chrono::milliseconds(timeoutMs), hasFile)) {
            return std::nullopt; // Timeout
        }
    }
    
    // Find and return the file
    for (const auto& entry : m_queue) {
        if (predicate(entry.filePath)) {
            return entry.filePath;
        }
    }
    
    return std::nullopt; // Should not get here
}

bool ProcessingQueue::isEmpty() const {
    std::lock_guard<std::mutex> lock(m_mutex);
    return m_queue.empty();
}

size_t ProcessingQueue::size() const {
    std::lock_guard<std::mutex> lock(m_mutex);
    return m_queue.size();
}

void ProcessingQueue::clear() {
    std::lock_guard<std::mutex> lock(m_mutex);
    m_queue.clear();
}

void ProcessingQueue::signal() {
    m_condition.notify_all();
}
```

## 5. Main PcapFileDiscovery class

### PcapFileDiscovery.h
```cpp
#pragma once

#include "DirectoryWatcher.h"
#include "FileStateManager.h"
#include "ProcessingQueue.h"
#include "Log.h"
#include <string>
#include <memory>
#include <atomic>
#include <functional>
#include <optional>
#include <signal.h>

/**
 * Configuration for file discovery
 */
struct FileDiscoveryConfig {
    bool watchRecursively = false;
    int maxGrowthChecks = 3;
    int growthCheckIntervalMs = 500;
    bool ignoreDotFiles = true;
};

/**
 * Event-driven PCAP file discovery system using inotify.
 * Monitors a directory for new, modified, and deleted files.
 * Maintains file states and provides ordered access to processable files.
 */
class PcapFileDiscovery {
public:
    /**
     * Create a file discovery component for the specified directory
     * 
     * @param directory Path to directory to monitor
     * @param config Configuration options
     */
    explicit PcapFileDiscovery(
        const std::string& directory, 
        const FileDiscoveryConfig& config = FileDiscoveryConfig());
    
    /**
     * Destructor stops monitoring and cleans up resources
     */
    ~PcapFileDiscovery();

    // Non-copyable
    PcapFileDiscovery(const PcapFileDiscovery&) = delete;
    PcapFileDiscovery& operator=(const PcapFileDiscovery&) = delete;

    /**
     * Start monitoring and file discovery
     * 
     * @return True if started successfully
     */
    bool start();
    
    /**
     * Stop monitoring and cleanup resources
     */
    void stop();
    
    /**
     * Check if discovery is active
     * 
     * @return True if running
     */
    bool isRunning() const;

    /**
     * Get the next file ready for processing (non-blocking)
     * 
     * @return Path to file ready for processing, or empty if none
     */
    std::optional<std::string> getNextFile();
    
    /**
     * Wait for the next file to be ready for processing
     * 
     * @param timeoutMs Maximum time to wait in milliseconds (0 = wait forever)
     * @return Path to file ready for processing, or empty on timeout
     */
    std::optional<std::string> waitForNextFile(unsigned int timeoutMs = 0);
    
    /**
     * Mark a file as processed
     * 
     * @param filePath Path to the file to mark as processed
     * @return True if file was found and marked
     */
    bool markFileProcessed(const std::string& filePath);

    /**
     * Check if a file is a growing file that has new data
     * 
     * @param filePath Path to check
     * @return True if the file is growing
     */
    bool hasNewData(const std::string& filePath);
    
    /**
     * Get the current state of a file
     * 
     * @param filePath Path to the file to check
     * @return Current state of the file
     */
    FileState getFileState(const std::string& filePath) const;
    
    /**
     * Get the total number of files in specified state
     * 
     * @param state State to count (or all states if omitted)
     * @return Number of files in the specified state
     */
    int getFileCount(std::optional<FileState> state = std::nullopt) const;
    
    /**
     * Check if a file exists in our tracking
     * 
     * @param filePath Path to check
     * @return True if file is being tracked
     */
    bool fileExists(const std::string& filePath) const;
    
    /**
     * Set up signal handlers for safe shutdown
     */
    static void setupSignalHandlers();
    
private:
    /**
     * Handle file events from the directory watcher
     * 
     * @param event File event
     */
    void onFileEvent(const FileEvent& event);
    
    /**
     * Check for files that have stopped growing
     */
    void checkGrowingFiles();
    
    /**
     * Handle SIGINT/SIGTERM signals
     * 
     * @param signal Signal number
     */
    static void signalHandler(int signal);
    
    /**
     * Worker thread for periodic tasks
     */
    void workerThread();
    
    // Directory being monitored
    std::string m_directory;
    FileDiscoveryConfig m_config;
    
    // Components
    std::unique_ptr<IDirectoryWatcher> m_watcher;
    std::unique_ptr<FileStateManager> m_stateManager;
    std::unique_ptr<ProcessingQueue> m_queue;
    
    // Threading
    std::atomic<bool> m_running;
    std::thread m_workerThread;
    
    // Static shutdown flag for signal handling
    static std::atomic<bool> s_shuttingDown;
    
    // Logger
    px::Log* log_;
};
```

### PcapFileDiscovery.cpp
```cpp
#include "PcapFileDiscovery.h"
#include <filesystem>
#include <thread>
#include <chrono>
#include <iostream>

namespace fs = std::filesystem;

// Initialize static shutdown flag
std::atomic<bool> PcapFileDiscovery::s_shuttingDown(false);

PcapFileDiscovery::PcapFileDiscovery(const std::string& directory, const FileDiscoveryConfig& config)
    : m_directory(directory),
      m_config(config),
      m_running(false),
      log_(PME_GET_LOGGER("PcapFileDiscovery"))
{
    if (!fs::exists(directory)) {
        throw std::runtime_error("Directory does not exist: " + directory);
    }
    
    if (!fs::is_directory(directory)) {
        throw std::runtime_error("Path is not a directory: " + directory);
    }
    
    // Create components
    m_watcher = std::make_unique<InotifyDirectoryWatcher>(directory, config.watchRecursively);
    m_stateManager = std::make_unique<FileStateManager>(
        std::make_unique<SizeProbeGrowthDetector>(),
        config.maxGrowthChecks);
    m_queue = std::make_unique<ProcessingQueue>();
    
    PME_LOG_INFO(log_, "PcapFileDiscovery initialized with directory: " << directory);
}

PcapFileDiscovery::~PcapFileDiscovery() {
    stop();
}

bool PcapFileDiscovery::start() {
    if (m_running.load(std::memory_order_relaxed)) {
        return true; // Already running
    }
    
    // Scan existing files in directory
    try {
        for (const auto& entry : fs::directory_iterator(m_directory)) {
            if (entry.is_regular_file()) {
                std::string filePath = entry.path().string();
                
                // Skip dotfiles if configured
                if (m_config.ignoreDotFiles && 
                    !filePath.empty() && 
                    fs::path(filePath).filename().string()[0] == '.') {
                    continue;
                }
                
                // Process as a new file
                if (m_stateManager->onFileCreated(filePath)) {
                    // If valid and added to state manager, also add to queue
                    if (m_stateManager->getFileState(filePath) != FileState::INVALID) {
                        m_queue->addFile(filePath, m_stateManager->getFileTimestamp(filePath));
                    }
                }
            }
        }
    } catch (const std::exception& e) {
        PME_LOG_ERROR(log_, "Error scanning directory: " << e.what());
        return false;
    }
    
    // Start the directory watcher
    if (!m_watcher->start([this](const FileEvent& event) { onFileEvent(event); })) {
        PME_LOG_ERROR(log_, "Failed to start directory watcher");
        return false;
    }
    
    // Start worker thread
    m_running.store(true, std::memory_order_relaxed);
    try {
        m_workerThread = std::thread(&PcapFileDiscovery::workerThread, this);
    } catch (const std::exception& e) {
        m_running.store(false, std::memory_order_relaxed);
        m_watcher->stop();
        PME_LOG_ERROR(log_, "Failed to start worker thread: " << e.what());
        return false;
    }
    
    PME_LOG_INFO(log_, "File discovery started");
    return true;
}

void PcapFileDiscovery::stop() {
    if (!m_running.load(std::memory_order_relaxed)) {
        return; // Already stopped
    }
    
    // Stop thread
    m_running.store(false, std::memory_order_relaxed);
    
    // Signal queue to wake any waiting threads
    m_queue->signal();
    
    // Stop watcher
    m_watcher->stop();
    
    // Join thread
    if (m_workerThread.joinable()) {
        m_workerThread.join();
    }
    
    PME_LOG_INFO(log_, "File discovery stopped");
}

bool PcapFileDiscovery::isRunning() const {
    return m_running.load(std::memory_order_relaxed);
}

std::optional<std::string> PcapFileDiscovery::getNextFile() {
    if (!isRunning()) {
        return std::nullopt;
    }
    
    // Get next file that is in UNPROCESSED_STATIC state
    return m_queue->getNextFile([this](const std::string& filePath) {
        return m_stateManager->getFileState(filePath) == FileState::UNPROCESSED_STATIC;
    });
}

std::optional<std::string> PcapFileDiscovery::waitForNextFile(unsigned int timeoutMs) {
    if (!isRunning()) {
        return std::nullopt;
    }
    
    // Wait for a file that is in UNPROCESSED_STATIC state
    return m_queue->waitForFile(
        [this](const std::string& filePath) {
            return m_stateManager->getFileState(filePath) == FileState::UNPROCESSED_STATIC;
        },
        timeoutMs
    );
}

bool PcapFileDiscovery::markFileProcessed(const std::string& filePath) {
    if (m_stateManager->markFileProcessed(filePath)) {
        // Remove from queue, no longer needed
        m_queue->removeFile(filePath);
        return true;
    }
    return false;
}

bool PcapFileDiscovery::hasNewData(const std::string& filePath) {
    return m_stateManager->getFileState(filePath) == FileState::GROWING;
}

FileState PcapFileDiscovery::getFileState(const std::string& filePath) const {
    return m_stateManager->getFileState(filePath);
}

int PcapFileDiscovery::getFileCount(std::optional<FileState> state) const {
    if (!state.has_value()) {
        // Count files in all states except INVALID
        int total = 0;
        total += m_stateManager->getFileCount(FileState::GROWING);
        total += m_stateManager->getFileCount(FileState::UNPROCESSED_STATIC);
        total += m_stateManager->getFileCount(FileState::PROCESSED_STATIC);
        return total;
    }
    
    return m_stateManager->getFileCount(state.value());
}

bool PcapFileDiscovery::fileExists(const std::string& filePath) const {
    return m_stateManager->hasFile(filePath);
}

void PcapFileDiscovery::setupSignalHandlers() {
    struct sigaction sa;
    sa.sa_handler = signalHandler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    
    sigaction(SIGINT, &sa, nullptr);
    sigaction(SIGTERM, &sa, nullptr);
    
    PME_LOG_INFO(PME_GET_LOGGER("PcapFileDiscovery"), "Signal handlers installed");
}

void PcapFileDiscovery::signalHandler(int signal) {
    s_shuttingDown.store(true, std::memory_order_relaxed);
    // Don't log here, just set the flag
}

void PcapFileDiscovery::onFileEvent(const FileEvent& event) {
    // Skip dotfiles if configured
    if (m_config.ignoreDotFiles && 
        !event.filePath.empty() && 
        fs::path(event.filePath).filename().string()[0] == '.') {
        return;
    }
    
    switch (event.type) {
        case FileEventType::CREATED:
            if (m_stateManager->onFileCreated(event.filePath)) {
                // If valid and added to state manager, also add to queue
                if (m_stateManager->getFileState(event.filePath) != FileState::INVALID) {
                    m_queue->addFile(
                        event.filePath, 
                        m_stateManager->getFileTimestamp(event.filePath));
                }
            }
            break;
            
        case FileEventType::MODIFIED:
            if (m_stateManager->onFileModified(event.filePath)) {
                // If state changed to valid, add to queue
                if (m_stateManager->getFileState(event.filePath) == FileState::UNPROCESSED_STATIC) {
                    m_queue->addFile(
                        event.filePath, 
                        m_stateManager->getFileTimestamp(event.filePath),
                        true);
                }
            }
            break;
            
        case FileEventType::DELETED:
            if (m_stateManager->onFileDeleted(event.filePath)) {
                // If was being tracked, remove from queue
                m_queue->removeFile(event.filePath);
            }
            break;
    }
}

void PcapFileDiscovery::checkGrowingFiles() {
    // Check for files that have stopped growing
    auto stoppedFiles = m_stateManager->checkStoppedGrowing();
    
    // Update queue for files that stopped growing
    for (const auto& filePath : stoppedFiles) {
        if (m_stateManager->getFileState(filePath) == FileState::UNPROCESSED_STATIC) {
            m_queue->addFile(
                filePath, 
                m_stateManager->getFileTimestamp(filePath),
                true); // Check if already in queue
        }
    }
}

void PcapFileDiscovery::workerThread() {
    PME_LOG_INFO(log_, "Worker thread started");
    
    try {
        while (m_running.load(std::memory_order_relaxed) && 
               !s_shuttingDown.load(std::memory_order_relaxed)) {
            
            // Check for files that have stopped growing
            checkGrowingFiles();
            
            // Sleep for a bit
            std::this_thread::sleep_for(std::chrono::milliseconds(m_config.growthCheckIntervalMs));
        }
    } catch (const std::exception& e) {
        PME_LOG_ERROR(log_, "Exception in worker thread: " << e.what());
    }
    
    PME_LOG_INFO(log_, "Worker thread exiting");
}
```

## 6. Forward Declarations for PacketProcessor

### PacketProcessor.h
```cpp
#pragma once

#include <string>
#include <functional>
#include "Log.h"

/**
 * Processes PCAP files to extract packet data for analysis.
 */
class PacketProcessor {
public:
    /**
     * Create a packet processor
     */
    PacketProcessor();
    
    /**
     * Destructor
     */
    ~PacketProcessor();
    
    /**
     * Process a PCAP file
     * 
     * @param filePath Path to the PCAP file
     * @param onComplete Function to call when processing completes
     */
    void processFile(const std::string& filePath, std::function<void()> onComplete = nullptr);
    
    /**
     * Process new data in a growing PCAP file
     * 
     * @param filePath Path to the growing file
     */
    void processGrowingFile(const std::string& filePath);
    
    /**
     * Stop any ongoing processing
     */
    void stop();
    
private:
    // This would contain the implementation details for packet processing
    px::Log* log_;
};
```

## 7. Engine Implementation

### Engine.h
```cpp
#pragma once

#include "PcapFileDiscovery.h"
#include "Log.h"
#include <memory>
#include <string>
#include <atomic>
#include <chrono>

// Forward declaration
class PacketProcessor;

/**
 * Core engine that orchestrates the packet processing pipeline.
 * Responsible for:
 * - Initializing and coordinating components
 * - Managing the processing lifecycle
 */
class Engine {
public:
    /**
     * Construct an engine that processes files from the given directory
     * 
     * @param inputDir Directory containing PCAP files to process
     */
    explicit Engine(const std::string& inputDir);
    
    /**
     * Destructor
     */
    ~Engine();

    // Non-copyable
    Engine(const Engine&) = delete;
    Engine& operator=(const Engine&) = delete;

    /**
     * Initialize engine components and prepare for processing
     */
    void init();

    /**
     * Signal the engine to stop processing
     */
    void stop();

    /**
     * Check if the engine should stop processing
     * 
     * @return True if shutdown has been requested
     */
    bool shouldStop() const {
        return m_shutdown.load(std::memory_order_relaxed);
    }

    /**
     * Run the main processing loop
     */
    void run();

private:
    /**
     * Set up signal handlers
     */
    void setupSignalHandlers();
    
    /**
     * Process a completed file
     * 
     * @param filePath Path to the file to process
     */
    void processFile(const std::string& filePath);
    
    /**
     * Process new data in a growing file
     * 
     * @param filePath Path to the growing file
     */
    void processGrowingFile(const std::string& filePath);
    
    /**
     * Called when file processing is complete
     * 
     * @param filePath Path to the processed file
     */
    void onFileProcessed(const std::string& filePath);

    // Input directory
    std::string m_inputDir;

    // Components
    std::shared_ptr<PcapFileDiscovery> m_fileDiscovery;
    std::shared_ptr<PacketProcessor> m_packetProcessor;

    // State
    std::atomic<bool> m_shutdown;

    // Logger
    px::Log* log_;
};
```

### Engine.cpp
```cpp
#include "Engine.h"
#include "PacketProcessor.h"
#include <iostream>
#include <thread>
#include <stdexcept>
#include <signal.h>

// Signal handler for Engine
static std::atomic<bool> s_engineSignalReceived(false);

static void engineSignalHandler(int signal) {
    s_engineSignalReceived.store(true, std::memory_order_relaxed);
}

Engine::Engine(const std::string& inputDir)
    : m_inputDir(inputDir),
      m_shutdown(false),
      log_(PME_GET_LOGGER("Engine")) 
{
    setupSignalHandlers();
}

Engine::~Engine() {
    stop();
}

void Engine::init() {
    PME_LOG_INFO(log_, "Initializing Engine with input directory: " << m_inputDir);

    try {
        // Configure file discovery
        FileDiscoveryConfig config;
        config.watchRecursively = false;
        config.maxGrowthChecks = 3;
        config.growthCheckIntervalMs = 500;
        
        // Create file discovery component
        m_fileDiscovery = std::make_shared<PcapFileDiscovery>(m_inputDir, config);
        
        // Install signal handlers for file discovery
        PcapFileDiscovery::setupSignalHandlers();
        
        // Start file discovery
        if (!m_fileDiscovery->start()) {
            throw std::runtime_error("Failed to start file discovery");
        }
        
        // Create packet processor
        m_packetProcessor = std::make_shared<PacketProcessor>();

        PME_LOG_INFO(log_, "Engine initialized successfully");
    }
    catch (const std::exception& e) {
        PME_LOG_ERROR(log_, "Failed to initialize engine: " << e.what());
        throw;
    }
}

void Engine::setupSignalHandlers() {
    struct sigaction sa;
    sa.sa_handler = engineSignalHandler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    
    sigaction(SIGINT, &sa, nullptr);
    sigaction(SIGTERM, &sa, nullptr);
    
    PME_LOG_INFO(log_, "Engine signal handlers installed");
}

void Engine::stop() {
    PME_LOG_INFO(log_, "Stopping engine");

    // Set shutdown flag
    m_shutdown.store(true, std::memory_order_relaxed);
    
    // Stop components
    if (m_fileDiscovery) {
        m_fileDiscovery->stop();
    }
    
    if (m_packetProcessor) {
        m_packetProcessor->stop();
    }

    PME_LOG_INFO(log_, "Engine stopped");
}

void Engine::run() {
    PME_LOG_INFO(log_, "Engine running");

    try {
        while (!shouldStop() && !s_engineSignalReceived.load(std::memory_order_relaxed)) {
            if (m_fileDiscovery) {
                // Wait for the next file with a timeout
                std::optional<std::string> filePath = m_fileDiscovery->waitForNextFile(500);
                
                if (filePath) {
                    processFile(*filePath);
                }
                
                // Check for growing files
                if (!shouldStop()) {
                    for (const auto& growingFile : m_fileDiscovery->getFilesInState(FileState::GROWING)) {
                        if (m_fileDiscovery->hasNewData(growingFile)) {
                            processGrowingFile(growingFile);
                        }
                    }
                }
            }
            else {
                PME_LOG_ERROR(log_, "No file discovery component, retrying init().");
                init();
            }
        }
    } 
    catch (const std::exception& e) {
        PME_LOG_ERROR(log_, "Exception in engine loop: " << e.what());
        stop();
        throw; // Rethrow to allow main to handle fatal errors
    }

    PME_LOG_INFO(log_, "Engine run loop exited");
}

void Engine::processFile(const std::string& filePath) {
    if (shouldStop()) {
        return;
    }
    
    PME_LOG_INFO(log_, "Processing file: " << filePath);
    
    try {
        // For testing, just mark as processed
        m_fileDiscovery->markFileProcessed(filePath);
        
        // TODO: When PacketProcessor is implemented:
        // if (m_packetProcessor) {
        //     m_packetProcessor->processFile(filePath, [this, filePath]() {
        //         onFileProcessed(filePath);
        //     });
        // }
    }
    catch (const std::exception& e) {
        PME_LOG_ERROR(log_, "Error processing file " << filePath << ": " << e.what());
    }
}

void Engine::processGrowingFile(const std::string& filePath) {
    if (shouldStop()) {
        return;
    }
    
    PME_LOG_INFO(log_, "Processing growing file: " << filePath);
    
    try {
        // TODO: When PacketProcessor is implemented:
        // if (m_packetProcessor) {
        //     m_packetProcessor->processGrowingFile(filePath);
        // }
    }
    catch (const std::exception& e) {
        PME_LOG_ERROR(log_, "Error processing growing file " << filePath << ": " << e.what());
    }
}

void Engine::onFileProcessed(const std::string& filePath) {
    if (shouldStop()) {
        return;
    }
    
    PME_LOG_INFO(log_, "File processing complete: " << filePath);
    
    try {
        m_fileDiscovery->markFileProcessed(filePath);
    }
    catch (const std::exception& e) {
        PME_LOG_ERROR(log_, "Error marking file as processed " << filePath << ": " << e.what());
    }
}
```

## 8. Main Program

### main.cpp
```cpp
#include <iostream>
#include <cstdlib>
#include <csignal>
#include <string>
#include <memory>
#include "Engine.h"
#include "Log.h"
#include <spapp/logging/logging.hpp>

int main(int argc, char** argv) {
    // Default input directory
    std::string inputDir = "/lxhome/songjoon/SBS/pme/tests/pcaps";

    // Override from arguments if provided
    if (argc > 1) {
        inputDir = argv[1];
    }

    // Initialize logging
    sp::logging::start(sp::logging::stdout_config());
    sp::logging::set_override(sp::logging::level::DEBUG);
    
    auto log_ = PME_GET_LOGGER("main");
    
    try {
        PME_LOG_INFO(log_, "Creating Packet Matching Engine");
        
        // Create and initialize engine
        std::unique_ptr<Engine> engine = std::make_unique<Engine>(inputDir);
        PME_LOG_INFO(log_, "Engine created");
        
        // Initialize engine
        engine->init();

        PME_LOG_INFO(log_, "Running Engine");
        
        // Run the engine (blocks until shutdown)
        engine->run();
        
        PME_LOG_INFO(log_, "Engine run completed");
    }
    catch (const std::exception& e) {
        PME_LOG_ERROR(log_, "Error: " << e.what());
        sp::logging::stop();
        return 1;
    }

    PME_LOG_INFO(log_, "Exiting normally");
    sp::logging::stop();
    return 0;
}
