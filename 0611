
### FILE: CMakeLists.txt ###
cmake_minimum_required(VERSION 3.25)
project(pme 
    VERSION 1.0.0
    DESCRIPTION "Packet Matching Engine"
    LANGUAGES CXX
)

# =============================================================================
# Build Configuration
# =============================================================================

list(APPEND CMAKE_MODULE_PATH /opt/sp/cmake/2.25/modules/)
include(Functions)
add_compile_options(-Wall -Wno-interference-size)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_POSITION_INDEPENDENT_CODE ON)

if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Release CACHE STRING "Build type" FORCE)
endif()

# =============================================================================
# Dependencies
# =============================================================================

# --- PcapPlusPlus (local install)
set(PCPP_ROOT "$ENV{HOME}/pcpp-install" CACHE PATH "PcapPlusPlus install root")
set(PCPP_INCLUDE_DIR "${PCPP_ROOT}/include/pcapplusplus")
set(PCPP_LIB_DIR     "${PCPP_ROOT}/lib64")
set(CMAKE_PREFIX_PATH "${PCPP_ROOT}")
find_package(PcapPlusPlus REQUIRED)

# --- Boost
set(BOOST_VERSION 1.60.0)
sp_find_package(Boost ${BOOST_VERSION})

# --- SP Application Framework
set(SPAPP_VERSION 31)
include(/opt/sp/spapp/${SPAPP_VERSION}/cmake/init.cmake)
set(RAZEAPI_VERSION 3.24.2)
set(MD_API_VERSION 1.606)
sp_find_package(razeapi ${RAZEAPI_VERSION} NODEPEND)
sp_find_package(md_api ${MD_API_VERSION} USEDEFAULTDEPENDCOMPONENTS)

# --- GoogleTest (for tests)
find_package(GTest REQUIRED)

# --- yaml-cpp
find_package(yaml-cpp REQUIRED)

# =============================================================================
# Source Files
# =============================================================================

# Core library sources (reusable components)
set(PME_CORE_SOURCES
    src/Config.cpp
    src/DropcopyHandler.cpp
    src/Engine.cpp
    src/PacketProcessor.cpp
    src/FlowClassifier.cpp
    src/ProtocolHandlerFactory.cpp
    src/SpcastV3Handler.cpp
    src/RazeHandler.cpp
)

set(PME_CORE_HEADERS
    src/Config.h
    src/DropcopyHandler.h
    src/Engine.h
    src/OutputFileWriter.h
    src/PacketProcessor.h
    src/FlowClassifier.h
    src/RuntimeContext.h
    src/IProtocolHandler.h
    src/Protocols.h
    src/SpcastV3Handler.h
    src/RazeHandler.h
)

# Application-specific sources
set(PME_APP_SOURCES
    src/main.cpp
)

set(PME_APP_HEADERS  
    src/Cli.h
)

# Test sources
set(PME_TEST_SOURCES
    tests/DropcopyHandler_test.cpp
)

# =============================================================================
# Interface Library for Common Dependencies
# =============================================================================

add_library(pme_deps INTERFACE)
target_link_libraries(pme_deps INTERFACE
    PcapPlusPlus::Pcap++
    PcapPlusPlus::Common++
    PcapPlusPlus::Packet++
    spapp_logging
    spapp_app
    boost_program_options-mt
    yaml-cpp
)
target_include_directories(pme_deps INTERFACE
    "${PCPP_INCLUDE_DIR}"
)
target_compile_features(pme_deps INTERFACE cxx_std_20)

# =============================================================================
# Core Library Target
# =============================================================================

add_library(pme_core ${PME_CORE_SOURCES} ${PME_CORE_HEADERS})
target_include_directories(pme_core PUBLIC 
    src 
    util
)
target_link_libraries(pme_core PUBLIC pme_deps)

# Make headers available for IDE
set_target_properties(pme_core PROPERTIES
    PUBLIC_HEADER "${PME_CORE_HEADERS}"
)

# =============================================================================
# Main Executable Target
# =============================================================================

add_executable(pme ${PME_APP_SOURCES} ${PME_APP_HEADERS})
target_include_directories(pme PRIVATE src util)
target_link_libraries(pme PRIVATE
    pme_core
    pme_deps
    spapp_app_cmdlne
)

# =============================================================================
# Tests (Optional)
# =============================================================================

option(PME_ENABLE_TESTS "Build unit tests" ON)

if(PME_ENABLE_TESTS)
    enable_testing()
    
    add_executable(pme_tests ${PME_TEST_SOURCES})
    target_include_directories(pme_tests PRIVATE src util)
    target_link_libraries(pme_tests PRIVATE
        pme_core
        pme_deps
        spapp_app_cmdlne
        GTest::gmock
        GTest::gtest
        GTest::gmock_main
    )
    
    # Register test with CTest
    include(GoogleTest)
    gtest_discover_tests(pme_tests)
    
    # Also add a simple test command for convenience
    add_test(NAME all_tests COMMAND pme_tests)
endif()

# =============================================================================
# Installation (Optional)
# =============================================================================

install(TARGETS pme pme_core
    RUNTIME DESTINATION bin
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
    PUBLIC_HEADER DESTINATION include/pme
)
### END: CMakeLists.txt ###

### FILE: README.md ###
# PME - Packet Matching Engine

A high-performance packet processing engine for matching ingress and egress network packets based on protocol-specific correlation logic.

## Overview

PME processes PCAP files to identify and match related ingress/egress packet pairs across different network flows. It supports multiple protocols and uses dropcopy data for correlation, making it ideal for analyzing trading system network traffic and measuring latencies.

## Features

- **Multi-Protocol Support**: SPCast V3 (UDP) and Raze (TCP) protocols
- **Flow-Based Classification**: Configurable ingress/egress flows with IP/port matching
- **TCP Stream Reassembly**: Handles fragmented TCP messages with dynamic buffering
- **Dropcopy Correlation**: Matches packets using order metadata from dropcopy logs
- **High Performance**: Single-threaded design with zero-copy processing where possible
- **Flexible Configuration**: YAML-based flow configuration
- **Real-Time Output**: Results written after each PCAP file for live monitoring
- **Dynamic Dropcopy Refresh**: Reloads dropcopy data for each file to capture updates

## Architecture

```
┌─────────────┐     ┌──────────────┐     ┌─────────────────┐
│ PCAP File   │────▶│ Flow         │────▶│ Protocol        │
│ Reader      │     │ Classifier   │     │ Handlers        │
└─────────────┘     └──────────────┘     └─────────────────┘
                            │                      │
                            ▼                      ▼
                    ┌──────────────┐      ┌────────────────┐
                    │ TCP          │      │ Message        │
                    │ Reassembly   │      │ Processing     │
                    └──────────────┘      └────────────────┘
                                                  │
                                                  ▼
                                          ┌────────────────┐
                                          │ Joined Packets │
                                          │ Output (CSV)   │
                                          └────────────────┘
```

## Building

### Prerequisites
- CMake 3.25+
- C++20 compiler
- PcapPlusPlus
- Boost 1.60+
- yaml-cpp

### Build Steps
```bash
mkdir build && cd build
cmake ..
make -j$(nproc)
```

## Usage

```bash
./pme -c config.yaml -d dropcopy.csv -w /path/to/pcap/files -o /output/dir
```

### Command Line Options
- `-c, --config`: Path to YAML configuration file
- `-d, --dropcopy`: Path to dropcopy CSV file
- `-w, --watch`: Directory containing PCAP files to process
- `-o, --output`: Output directory for results

## Configuration

### Flow Configuration (YAML)
```yaml
flow_sets:
  - set_name: "main_flow"
    ingress_flows:
      - protocol:
          communication: UDP
          message: SPCASTV3
        src_ip: "10.0.0.1"
        dst_ip: "239.1.1.1"
        dst_port: 30001
    egress_flows:
      - protocol:
          communication: TCP
          message: RAZE
        src_ip: "10.0.0.2"
        dst_ip: "192.168.1.100"
        dst_port: 40001
    watch_directory: "/data/pcaps"
    output_directory: "/data/output"

other_configs:
  debug_mode: false
  dropcopy_path: "/data/dropcopy.csv"
```

## Protocol Handlers

### SPCast V3 (UDP)
- Processes multicast market data packets
- Deduplicates messages by sequence number
- Extracts timestamps from packet headers

### Raze (TCP)
- Handles order entry protocol messages
- Supports TCP message framing with length prefixes
- Correlates using order tokens from dropcopy data

## Design Principles

1. **Single-Threaded**: Simplifies design, no synchronization overhead
2. **Zero-Copy**: Direct packet processing from memory-mapped files where possible
3. **Explicit Configuration**: All flows must be explicitly defined
4. **Clean Interfaces**: Protocol handlers implement a simple interface
5. **Memory Efficient**: Automatic cleanup of expired unmatched packets

## Output Format

PME outputs CSV files containing matched packet pairs with timing information:
```
entry_index,ingress_timestamp_ns,egress_timestamp_ns,latency_ns
0,1698765432123456789,1698765432123556789,100000
1,1698765432223456789,1698765432223656789,200000
```

### Output Behavior
- **Incremental Updates**: Output files are written after each PCAP file is processed
- **Overwrite Mode**: Files are overwritten (not appended) to prevent duplicates
- **Per Flow Set**: Each flow set gets its own CSV file: `{flow_set_name}_results.csv`
- **Live Monitoring**: Results can be monitored while the engine is running

## Performance Considerations

- Processes files sequentially (single-threaded by design)
- TCP flow buffers grow dynamically but are cleaned up on connection close
- Unmatched ingress packets expire after 5 seconds
- Efficient packet classification using exact IP/port matching
- Dropcopy data is reloaded for each PCAP file to capture updates

## License

[License information here]

### END: README.md ###

### FILE: config_example.yaml ###
# PME Configuration Example
# This file demonstrates all available configuration options

flow_sets:
  - set_name: test_strategy_1
    ingress_flows:
      - protocol: 
          communication: udp
          message: spcastv3
        src_ip: "239.254.64.2"
        dst_ip: ""
        src_port: 31103
        dst_port: 0
    egress_flows:
      - protocol:
          communication: tcp
          message: raze
        src_ip: ""
        dst_ip: "127.0.0.1"
        src_port: 0
        dst_port: 2528
    watch_directory: /apps/home/songjoon/pme/ # Directory containing PCAP files
    output_directory: ./ # Output directory for result csv files

other_configs:
  dropcopy_path: /apps/home/songjoon/pme/dropcopy/dropcopyfile #GTAd dropcopy file path
  debug_mode: false
### END: config_example.yaml ###

### FILE: src/Cli.h ###
#pragma once

#include <filesystem>
#include <iostream>
#include <string>

#include <boost/program_options.hpp>
#include <spapp/app_cmdlne/setup.hpp>

#include "Config.h"

namespace pme {

inline AppConfig parse_cli(int argc, char** argv)
{
    namespace po = boost::program_options;

    std::string config_path;
    po::options_description desc{"pme - Packet Matching Engine"};
    desc.add_options()
        ("config,c", po::value<std::string>(&config_path)->required(),
         "Path to YAML configuration file");
    
    sp::app_cmdlne::default_setup(argc, argv, desc, sp::app_cmdlne::standard_options::BUILD_INFO);

    if (config_path.empty()) {
        throw std::invalid_argument("Configuration file path cannot be empty");
    }

    // Load and validate configuration
    try {
        auto config = AppConfig::load(config_path);
        std::cout << "Configuration loaded successfully from: " << config_path << std::endl;
        std::cout << "Number of flow sets: " << config.flow_sets.size() << std::endl;
        
        for (const auto& flow_set : config.flow_sets) {
            std::cout << "\nFlow Set: " << flow_set.set_name << std::endl;
            std::cout << "  Watch directory: " << flow_set.watch_directory << std::endl;
            std::cout << "  Output directory: " << flow_set.output_directory << std::endl;
            std::cout << "  Ingress flows: " << flow_set.ingress_flows.size() << std::endl;
            for (size_t i = 0; i < flow_set.ingress_flows.size(); ++i) {
                const auto& flow = flow_set.ingress_flows[i];
                std::cout << "    [" << i << "] " << flow.protocol.toString()
                          << " (" << (flow.src_ip.empty() ? "any" : flow.src_ip)
                          << ":" << (flow.src_port == 0 ? "any" : std::to_string(flow.src_port))
                          << " -> " << (flow.dst_ip.empty() ? "any" : flow.dst_ip)
                          << ":" << (flow.dst_port == 0 ? "any" : std::to_string(flow.dst_port))
                          << ")" << std::endl;
            }
            std::cout << "  Egress flows: " << flow_set.egress_flows.size() << std::endl;
            for (size_t i = 0; i < flow_set.egress_flows.size(); ++i) {
                const auto& flow = flow_set.egress_flows[i];
                std::cout << "    [" << i << "] " << flow.protocol.toString()
                          << " (" << (flow.src_ip.empty() ? "any" : flow.src_ip)
                          << ":" << (flow.src_port == 0 ? "any" : std::to_string(flow.src_port))
                          << " -> " << (flow.dst_ip.empty() ? "any" : flow.dst_ip)
                          << ":" << (flow.dst_port == 0 ? "any" : std::to_string(flow.dst_port))
                          << ")" << std::endl;
            }
        }
        return config;
    } catch (const std::exception& e) {
        std::cerr << "Error loading configuration: " << e.what() << std::endl;
        throw;
    }
}

} // namespace pme

### END: src/Cli.h ###

### FILE: src/Config.cpp ###
#include "Config.h"
#include <yaml-cpp/yaml.h>
#include <filesystem>
#include <stdexcept>
#include <iostream>
#include "Protocols.h"

namespace pme {

Protocol parseProtocol(const YAML::Node& protocol_node) {
    if(!protocol_node["communication"] || !protocol_node["message"]) {
        throw std::runtime_error("Protocol definition must include 'communication' and 'message' fields");
    }

    Protocol protocol;
    std::string comm_str = protocol_node["communication"].as<std::string>();
    std::string msg_str = protocol_node["message"].as<std::string>();
    
    protocol.communication = stringToCommunicationProtocol(comm_str);
    protocol.message = stringToMessageProtocol(msg_str);

    if(!protocol.is_valid()) {
        throw std::runtime_error("Invalid protocol specified: " + comm_str + "/" + msg_str);
    }

    return protocol;
}

Flow parseFlow(const YAML::Node& node, FlowDirection direction, const std::string& parent_set) {
    Flow flow;
    flow.parent_set = parent_set;
    flow.direction = direction;
    
    // Parse protocol
    if(!node["protocol"]) {
        throw std::runtime_error("Flow must have a 'protocol' field");
    }
    flow.protocol = parseProtocol(node["protocol"]);
    
    // Parse IP addresses
    if(node["src_ip"]) {
        flow.src_ip = node["src_ip"].as<std::string>();
    }
    if(node["dst_ip"]) {
        flow.dst_ip = node["dst_ip"].as<std::string>();
    }
    
    // Parse ports
    if(node["src_port"]) {
        flow.src_port = node["src_port"].as<uint16_t>();
    }
    if(node["dst_port"]) {
        flow.dst_port = node["dst_port"].as<uint16_t>();
    }
    
    return flow;
}

FlowSet parseFlowSet(const YAML::Node& node) {
    FlowSet flow_set;
    
    // Parse set name
    if(!node["set_name"]) {
        throw std::runtime_error("Flow set must have a 'set_name' field");
    }
    flow_set.set_name = node["set_name"].as<std::string>();
    
    // Parse ingress flows
    if(node["ingress_flows"]) {
        for(const auto& flow_node : node["ingress_flows"]) {
            flow_set.ingress_flows.push_back(
                parseFlow(flow_node, FlowDirection::INGRESS, flow_set.set_name)
            );
        }
    }
    
    // Parse egress flows
    if(node["egress_flows"]) {
        for(const auto& flow_node : node["egress_flows"]) {
            flow_set.egress_flows.push_back(
                parseFlow(flow_node, FlowDirection::EGRESS, flow_set.set_name)
            );
        }
    }
    
    // Parse directories
    if(node["watch_directory"]) {
        flow_set.watch_directory = node["watch_directory"].as<std::string>();
    }
    if(node["output_directory"]) {
        flow_set.output_directory = node["output_directory"].as<std::string>();
    }
    
    return flow_set;
}

AppConfig AppConfig::load(const std::string& config_path) {
    AppConfig config;
    
    try {
        // Check if file exists
        if(!std::filesystem::exists(config_path)) {
            throw std::runtime_error("Configuration file not found: " + config_path);
        }
        
        // Load YAML file
        YAML::Node root = YAML::LoadFile(config_path);
        
        // Parse flow sets
        if(root["flow_sets"]) {
            for(const auto& flow_set_node : root["flow_sets"]) {
                config.flow_sets.push_back(parseFlowSet(flow_set_node));
            }
        }
        
        // Parse other configs
        if(root["other_configs"]) {
            const auto& other = root["other_configs"];
            if(other["debug_mode"]) {
                config.debug_mode = other["debug_mode"].as<bool>();
            }
            if(other["dropcopy_path"]) {
                config.dropcopy_path = other["dropcopy_path"].as<std::string>();
            }
        }
        
        // Validate the loaded configuration
        config.validate();
        
    } catch(const YAML::Exception& e) {
        throw std::runtime_error("Failed to parse YAML configuration: " + std::string(e.what()));
    } catch(const std::exception& e) {
        throw std::runtime_error("Failed to load configuration: " + std::string(e.what()));
    }
    
    return config;
}

void AppConfig::validate() const {
    // Validate that we have at least one flow set
    if(flow_sets.empty()) {
        throw std::runtime_error("Configuration must define at least one flow set");
    }
    
    // Validate each flow set
    for(const auto& flow_set : flow_sets) {
        if(flow_set.set_name.empty()) {
            throw std::runtime_error("Flow set must have a non-empty name");
        }
        
        // Check that flow set has at least one flow
        if(flow_set.ingress_flows.empty() || flow_set.egress_flows.empty()) {
            throw std::runtime_error("Flow set '" + flow_set.set_name + 
                                   "' must have at least one pair of ingress/egress flows");
        }
        
        // Validate each flow
        auto validate_flow = [&](const Flow& flow) {
            if(!flow.protocol.is_valid()) {
                throw std::runtime_error("Invalid protocol in flow for set '" + 
                                       flow_set.set_name + "'");
            }
        };
        
        for(const auto& flow : flow_set.ingress_flows) {
            validate_flow(flow);
        }
        for(const auto& flow : flow_set.egress_flows) {
            validate_flow(flow);
        }
    }
}

} // namespace pme
### END: src/Config.cpp ###

### FILE: src/Config.h ###
#pragma once

#include <string>
#include <cstdint>
#include <vector>
#include "Protocols.h"

namespace pme {

enum class FlowDirection {
    INGRESS,
    EGRESS
};

struct Flow {
    std::string parent_set;  // Name of the parent flow set
    Protocol protocol;
    std::string src_ip;
    std::string dst_ip;
    uint16_t src_port = 0;
    uint16_t dst_port = 0;
    FlowDirection direction;
};

struct FlowSet {
    std::string set_name;
    std::vector<Flow> ingress_flows;
    std::vector<Flow> egress_flows;
    std::string watch_directory;
    std::string output_directory;
};

struct AppConfig {
    std::vector<FlowSet> flow_sets;
    std::string dropcopy_path;

    // Other configs
    bool debug_mode = false;

    static AppConfig load(const std::string& config_path);
    void validate() const;
};

} // namespace pme 
### END: src/Config.h ###

### FILE: src/DropcopyHandler.cpp ###
#include "DropcopyHandler.h"

namespace pme {

DropcopyHandler::DropcopyHandler(const std::string dropcopy_path)
    : dir_(std::move(dropcopy_path)), log_(PME_GET_LOGGER("DropcopyHandler"))
{
    map_ = parseDropcopy(dir_);

    PME_LOG_INFO(log_, "Parsed " << map_.size() << " entries from dropcopy file");
}

} // namespace pme
### END: src/DropcopyHandler.cpp ###

### FILE: src/DropcopyHandler.h ###
#pragma once

#include <charconv>
#include <chrono>
#include <cstdint>
#include <ctime>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <regex>
#include <sstream>
#include <string>
#include <string_view>
#include <unordered_map>
#include <utility>

#include "Log.h"

namespace pme {

// Holds both known and unknown fields
struct LatencyStats {
    std::string event_type{};      // Explicitly initialize strings
    uint64_t    md_seq_num        = 0;
    std::string md_feed_name{};    // Explicitly initialize strings
    int         exch_seq_num      = 0;
    int         exch_src_id       = 0;
    uint64_t    md_sec_ric        = 0;
    int         oms_queue_size    = 0;
    uint64_t before_md_recv       = 0;
    uint64_t after_md_recv        = 0;
    uint64_t before_md_decode     = 0;
    uint64_t after_md_decode      = 0;
    uint64_t before_strategy      = 0;
    uint64_t before_slice_new     = 0;
    uint64_t before_soflomo_check = 0;
    uint64_t before_oms_send      = 0;
    uint64_t before_driver_send   = 0;
    uint64_t after_driver_send    = 0;
    uint64_t md_recv_time         = 0;
    uint64_t md_send_time         = 0;
    uint64_t md_exchange_time     = 0;
    int md_event_id               = 0;
    uint64_t hw_recv_time         = 0;

    // Default constructor to ensure all members are initialized
    LatencyStats() = default;
    
    // Copy constructor
    LatencyStats(const LatencyStats&) = default;
    
    // Move constructor
    LatencyStats(LatencyStats&&) = default;
    
    // Copy assignment
    LatencyStats& operator=(const LatencyStats&) = default;
    
    // Move assignment
    LatencyStats& operator=(LatencyStats&&) = default;

    friend std::ostream& operator<<(std::ostream& os, LatencyStats const& s) {
        os << "event_type=" << s.event_type
           << " md_seq_num=" << s.md_seq_num
           << " md_feed_name=" << s.md_feed_name
           << " exch_seq_num=" << s.exch_seq_num
           << " exch_src_id=" << s.exch_src_id
           << " md_sec_ric=" << s.md_sec_ric
           << " oms_queue_size=" << s.oms_queue_size
           << " before_md_recv=" << s.before_md_recv
           << " after_md_recv=" << s.after_md_recv
           << " before_md_decode=" << s.before_md_decode
           << " after_md_decode=" << s.after_md_decode
           << " before_strategy=" << s.before_strategy
           << " before_slice_new=" << s.before_slice_new
           << " before_soflomo_check=" << s.before_soflomo_check
           << " before_oms_send=" << s.before_oms_send
           << " before_driver_send=" << s.before_driver_send
           << " after_driver_send=" << s.after_driver_send
           << " md_recv_time=" << s.md_recv_time
           << " md_send_time=" << s.md_send_time
           << " md_exchange_time=" << s.md_exchange_time
           << " md_event_id=" << s.md_event_id
           << " hw_recv_time=" << s.hw_recv_time;

        return os;
    }
};

class DropcopyHandler
{
public:
    DropcopyHandler(const std::string dropcopy_path);

    ~DropcopyHandler() = default;

    // Parse UTC timestamp string_view to uint64_t nanoseconds since epoch
    // format: YYYY-MM-DD HH:MM:SS.nnnnnnnnn
    uint64_t parseTimestamp(std::string_view timestamp) {
        // Expected format: "YYYY-MM-DD HH:MM:SS.nnnnnnnnn"
        // Positions:       01234567890123456789012345567
        
        // Initialize all variables to avoid -Wmaybe-uninitialized
        int year = 0, month = 0, day = 0, hour = 0, minute = 0, second = 0;

        // Validate minimum length
        if (timestamp.length() < 19) {
            return 0;  // Invalid timestamp format
        }

        auto res = std::from_chars(timestamp.data(), timestamp.data() + 4, year);
        if (res.ec != std::errc()) return 0;  // Failed to parse year
        
        res = std::from_chars(timestamp.data() + 5, timestamp.data() + 7, month);
        if (res.ec != std::errc()) return 0;  // Failed to parse month
        
        res = std::from_chars(timestamp.data() + 8, timestamp.data() + 10, day);
        if (res.ec != std::errc()) return 0;  // Failed to parse day
        
        res = std::from_chars(timestamp.data() + 11, timestamp.data() + 13, hour);
        if (res.ec != std::errc()) return 0;  // Failed to parse hour
        
        res = std::from_chars(timestamp.data() + 14, timestamp.data() + 16, minute);
        if (res.ec != std::errc()) return 0;  // Failed to parse minute
        
        res = std::from_chars(timestamp.data() + 17, timestamp.data() + 19, second);
        if (res.ec != std::errc()) return 0;  // Failed to parse second

        // Parse nanoseconds
        uint64_t nanos_frac = 0;
        if (timestamp.length() > 20 && timestamp[19] == '.') {
            // Get nanosecond substring
            auto nano_start = timestamp.data() + 20;
            auto nano_len = std::min<size_t>(9, timestamp.length() - 20);

            // Parse what we have
            uint64_t parsed_value = 0;
            std::from_chars(nano_start, nano_start + nano_len, parsed_value);

            // Scale to nanoseconds (multiply by 10^(9-nano_len))
            uint64_t scale = 1;
            for (size_t i = nano_len; i < 9; ++i) {
                scale *= 10;
            }
            nanos_frac = parsed_value * scale;
        }

        // Convert to UTC time
        std::tm tm = {};
        tm.tm_year = year - 1900;
        tm.tm_mon = month - 1;
        tm.tm_mday = day;
        tm.tm_hour = hour;
        tm.tm_min = minute;
        tm.tm_sec = second;
        tm.tm_isdst = 0;

        // timegm for UTC (available on Linux)
        std::time_t time_seconds = timegm(&tm);

        // Check for negative time (before 1970)
        if (time_seconds < 0) {
            return 0; // or handle pre-1970 dates as needed
        }

        // Now safe to cast
        return static_cast<uint64_t>(time_seconds) * 1'000'000'000ULL + nanos_frac;
    }

    // Key-Value parser
    std::pair<std::string_view,std::string_view>
        parseKV(std::string_view text, size_t& pos)
    {
        // skip whitespace
        while (pos < text.size() && isspace(text[pos])) pos++;
        auto start = pos;
        // read key
        while (pos < text.size() && text[pos] != '=') pos++;
        auto key = text.substr(start, pos - start);
        pos++; // skip '='
        // skip whitespace
        while (pos < text.size() && isspace(text[pos])) pos++;
        // read value (up to comma or end)
        start = pos;
        // Add bounds check before accessing text[pos]
        bool in_quotes = (pos < text.size() && text[pos]=='\'');
        if (in_quotes) pos++;
        while (pos < text.size() &&
               (in_quotes ? text[pos] != '\'' : text[pos] != ',' && text[pos] != '}'))
        {
            pos++;
        }
        auto value = text.substr(start, pos - start);
        if (in_quotes && pos<text.size() && text[pos]=='\'') pos++;
        // skip comma
        if (pos<text.size() && text[pos]==',') pos++;
        return {key, value};
    }

    std::string_view trim_sv(std::string_view sv) {
        size_t b = 0, e = sv.size();
        while (b < e && std::isspace((unsigned char)sv[b])) ++b;
        while (e > b && std::isspace((unsigned char)sv[e-1])) --e;
        return sv.substr(b, e-b);
    }

    std::unordered_map<uint64_t, LatencyStats>
    parseDropcopy(const std::string& filename) {
        static const std::regex line_re{
            R"(.*clordid\s*=\s*(\d+)\s*,\s*latency_stats\s*=\s*\{(.*)\}.*)"};
        std::unordered_map<uint64_t, LatencyStats> out;
        std::ifstream in{filename};
        if (!in.is_open()) {
            PME_LOG_ERROR(log_, "Failed to open dropcopy file: " << filename);
            return out;
        }
        
        std::string line;
        int line_num = 0;
        while (std::getline(in, line)) {
            line_num++;
            std::smatch m;
            if (!std::regex_match(line, m, line_re)) {
                continue;
            }
            
            try {
                uint64_t cid = std::stoull(m[1].str());
                std::string body_str = m[2].str();
                std::string_view body = body_str;

                LatencyStats stats{};  // Use value initialization
                size_t pos = 0;
                while (pos < body.size()) {
                    auto [k_raw, v_raw] = parseKV(body, pos);
                    auto k = trim_sv(k_raw);
                    auto v = trim_sv(v_raw);

                    if (k == "event_type") {
                        stats.event_type = std::string(v);
                    } else if (k == "md_seq_num") {
                        stats.md_seq_num = std::stoull(std::string(v));
                    } else if (k == "md_feed_name") {
                        // strip quotes if present - add bounds checking
                        stats.md_feed_name = (!v.empty() && v.front()=='\'' && v.back()=='\'')
                            ? std::string(v.substr(1, v.size()-2))
                            : std::string(v);
                    } else if (k == "exch_seq_num") {
                        stats.exch_seq_num = std::stoi(std::string(v));
                    } else if (k == "exch_src_id") {
                        stats.exch_src_id = std::stoi(std::string(v));
                    } else if (k == "md_sec_ric") {
                        stats.md_sec_ric = std::stoull(std::string(v));
                    } else if (k == "oms_queue_size") {
                        stats.oms_queue_size = std::stoi(std::string(v));
                    } else if (k == "before_md_recv") {
                        stats.before_md_recv = parseTimestamp(v);
                        if (stats.before_md_recv == 0 && !v.empty()) {
                            PME_LOG_WARN(log_, "Failed to parse timestamp 'before_md_recv': " << v);
                        }
                    } else if (k == "after_md_recv") {
                        stats.after_md_recv = parseTimestamp(v);
                    } else if (k == "before_md_decode") {
                        stats.before_md_decode = parseTimestamp(v);
                    } else if (k == "after_md_decode") {
                        stats.after_md_decode = parseTimestamp(v);
                    } else if (k == "before_strategy") {
                        stats.before_strategy = parseTimestamp(v);
                    } else if (k == "before_slice_new") {
                        stats.before_slice_new = parseTimestamp(v);
                    } else if (k == "before_soflomo_check") {
                        stats.before_soflomo_check = parseTimestamp(v);
                    } else if (k == "before_oms_send") {
                        stats.before_oms_send = parseTimestamp(v);
                    } else if (k == "before_driver_send") {
                        stats.before_driver_send = parseTimestamp(v);
                    } else if (k == "after_driver_send") {
                        stats.after_driver_send = parseTimestamp(v);
                    } else if (k == "md_recv_time") {
                        stats.md_recv_time = parseTimestamp(v);
                        if (stats.md_recv_time == 0 && !v.empty()) {
                            PME_LOG_WARN(log_, "Failed to parse timestamp 'md_recv_time': " << v);
                        }
                    } else if (k == "md_send_time") {
                        stats.md_send_time = parseTimestamp(v);
                        if (stats.md_send_time == 0 && !v.empty()) {
                            PME_LOG_WARN(log_, "Failed to parse timestamp 'md_send_time': " << v);
                        }
                    } else if (k == "md_exchange_time") {
                        stats.md_exchange_time = parseTimestamp(v);
                    } else if (k == "md_event_id") {
                        stats.md_event_id = std::stoi(std::string(v));
                    }
                }
                // Use operator[] to avoid -Wmaybe-uninitialized warning
                // This constructs the value in-place if it doesn't exist
                out[cid] = std::move(stats);
            } catch (const std::exception& e) {
                PME_LOG_ERROR(log_, "Error parsing line " << line_num << ": " << e.what());
            }
        }
        
        return out;
    }

    const std::unordered_map<uint64_t, LatencyStats>& getMapRef() const
    {
        return map_;
    }

private:
    std::unordered_map<uint64_t, LatencyStats> map_;
    std::string dir_;
    px::Log* log_;
};

} // namespace pme

### END: src/DropcopyHandler.h ###

### FILE: src/Engine.cpp ###
#include "Engine.h"

#include <chrono>
#include <filesystem>
#include <iostream>
#include <thread>

#include <spapp/app/wait.hpp>

#include "OutputFileWriter.h"

namespace pme {

Engine::Engine(std::shared_ptr<RuntimeContext> ctx, const AppConfig& config)
    : ctx_(ctx),
      config_(config),
      log_(PME_GET_LOGGER("Engine"))
{
    PME_LOG_INFO(log_, "Engine initialized with " << config_.flow_sets.size() << " flow sets:");
    for (const auto& flow_set : config_.flow_sets) {
        PME_LOG_INFO(log_, "  Flow set: " << flow_set.set_name);
        PME_LOG_INFO(log_, "    Watch directory: " << flow_set.watch_directory);
        PME_LOG_INFO(log_, "    Output directory: " << flow_set.output_directory);
        PME_LOG_INFO(log_, "    Ingress flows: " << flow_set.ingress_flows.size());
        PME_LOG_INFO(log_, "    Egress flows: " << flow_set.egress_flows.size());
    }
}

std::filesystem::path Engine::getNextPcapFile() {
    namespace fs = std::filesystem;
    
    // Check all flow sets' watch directories
    for (const auto& flow_set : config_.flow_sets) {
        if (!fs::exists(flow_set.watch_directory)) {
            continue;
        }
        
        for (const auto& entry : fs::directory_iterator(flow_set.watch_directory)) {
            if (entry.is_regular_file()) {
                auto path = entry.path();
                auto extension = path.extension().string();
                
                // Check if it's a pcap file
                if (extension == ".pcap" || extension == ".pcapng") {
                    // Check if we've already processed this file
                    if (processed_files_.find(path.string()) == processed_files_.end()) {
                        return path;
                    }
                }
            }
        }
    }
    
    return {};
}

void Engine::run() {
    std::thread t1(&Engine::workerMain, this);

    int sig = sp::app::wait();

    PME_LOG_INFO(log_, "Shutdown signal " << sig << " received");
    
    ctx_->stop.store(true);
    t1.join();

    // Final output write at shutdown
    writeOutputFiles();
}

void Engine::workerMain() {
    PacketProcessor packet_processor(ctx_, config_);
    
    PME_LOG_INFO(log_, "Engine started. Processing PCAP files from configured watch directories.");
    
    while (!ctx_->stop.load()) {
        auto pcap_file = getNextPcapFile();
        
        if (!pcap_file.empty()) {
            PME_LOG_INFO(log_, "Processing file: " << pcap_file.string());
            
            // Process the file - returns map of flow_set_name -> vector<JoinedPackets>
            auto flowSetResults = packet_processor.processFile(pcap_file.string());
            
            // Merge results into outputMap by flow set
            for (const auto& [flow_set_name, joined_packets] : flowSetResults) {
                // Append new results to existing vector for this flow set
                outputMap_[flow_set_name].insert(
                    outputMap_[flow_set_name].end(),
                    joined_packets.begin(),
                    joined_packets.end()
                );
            }
            
            // Mark file as processed
            processed_files_.insert(pcap_file.string());
            
            // Log summary
            size_t total_entries = 0;
            for (const auto& [name, packets] : outputMap_) {
                total_entries += packets.size();
            }
            PME_LOG_INFO(log_, "Finished processing: " << pcap_file.string() 
                         << " - Total flow sets: " << outputMap_.size()
                         << " - Total entries: " << total_entries);
            
            // Write output files after each PCAP file (overwrites existing)
            writeOutputFiles();
        } else {
            // No new files, wait a bit before checking again
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
    }
}

void Engine::writeOutputFiles() {
    // Write output for each flow set to its specific output directory
    for (const auto& [flow_set_name, joined_packets] : outputMap_) {
        // Find the flow set config to get its output directory
        std::string output_dir;
        for (const auto& flow_set : config_.flow_sets) {
            if (flow_set.set_name == flow_set_name) {
                output_dir = flow_set.output_directory;
                break;
            }
        }
        
        if (output_dir.empty()) {
            PME_LOG_ERROR(log_, "No output directory configured for flow set: " << flow_set_name);
            continue;
        }
        
        // Ensure directory ends with separator
        if (!output_dir.empty() && output_dir.back() != '/' && output_dir.back() != '\\') {
            output_dir += "/";
        }
        
        if(OutputFileWriter::writeFlowSet(joined_packets, flow_set_name, output_dir))
        {
            PME_LOG_INFO(log_, "Output written for flow set '" << flow_set_name 
                         << "' to " << output_dir << flow_set_name << "_results.csv"
                         << " (" << joined_packets.size() << " entries)");
        }
        else
        {
            PME_LOG_ERROR(log_, "Failed to write output for flow set '" << flow_set_name << "'");
        }
    }
}

} // namespace pme
### END: src/Engine.cpp ###

### FILE: src/Engine.h ###
#pragma once

#include <memory>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <vector>
#include <filesystem>

#include "Log.h"
#include "DropcopyHandler.h"
#include "Config.h"
#include "PacketProcessor.h"
#include "RuntimeContext.h"

namespace pme {

class Engine {
public:
    Engine(std::shared_ptr<RuntimeContext> ctx, const AppConfig& config);
    ~Engine() = default;
    void run();

private:
    void workerMain();
    std::filesystem::path getNextPcapFile();
    
    std::shared_ptr<RuntimeContext> ctx_;
    std::unordered_map<std::string, std::vector<JoinedPackets>> outputMap_;
    AppConfig config_;
    
    std::unordered_set<std::string> processed_files_;
    px::Log* log_;
    
    void writeOutputFiles();  // Helper to write output files
};

} // namespace pme

### END: src/Engine.h ###

### FILE: src/FlowClassifier.cpp ###
#include "FlowClassifier.h"
#include <TcpReassembly.h>

namespace pme {

// Constructor - build the flow list from configuration
FlowClassifier::FlowClassifier(const AppConfig& config) {
    // Copy flow sets to keep them alive
    flow_sets_ = config.flow_sets;
    
    // Build flat list of all flows for efficient matching
    for (const auto& flow_set : flow_sets_) {
        // Add ingress flows
        for (const auto& flow : flow_set.ingress_flows) {
            all_flows_.push_back(&flow);
        }
        // Add egress flows
        for (const auto& flow : flow_set.egress_flows) {
            all_flows_.push_back(&flow);
        }
    }
}

// Helper - match packet against a specific flow
bool FlowClassifier::matchesPacket(const pcpp::Packet& packet, const Flow& flow) const {
    // Get IPv4 layer (only IPv4 supported for now)
    auto* ipv4 = packet.getLayerOfType<pcpp::IPv4Layer>();
    if (!ipv4) {
        return false;
    }

    // Check IP addresses
    if (!flow.src_ip.empty() && ipv4->getSrcIPAddress().toString() != flow.src_ip) {
        return false;
    }
    if (!flow.dst_ip.empty() && ipv4->getDstIPAddress().toString() != flow.dst_ip) {
        return false;
    }

    // Check ports
    if (flow.src_port != 0 || flow.dst_port != 0) {
        if (packet.isPacketOfType(pcpp::TCP)) {
            auto* tcp = packet.getLayerOfType<pcpp::TcpLayer>();
            if (!tcp) return false;

            if (flow.src_port != 0 && pcpp::netToHost16(tcp->getTcpHeader()->portSrc) != flow.src_port) {
                return false;
            }
            if (flow.dst_port != 0 && pcpp::netToHost16(tcp->getTcpHeader()->portDst) != flow.dst_port) {
                return false;
            }
        } else if (packet.isPacketOfType(pcpp::UDP)) {
            auto* udp = packet.getLayerOfType<pcpp::UdpLayer>();
            if (!udp) return false;

            if (flow.src_port != 0 && pcpp::netToHost16(udp->getUdpHeader()->portSrc) != flow.src_port) {
                return false;
            }
            if (flow.dst_port != 0 && pcpp::netToHost16(udp->getUdpHeader()->portDst) != flow.dst_port) {
                return false;
            }
        } else {
            // If ports are specified but packet is neither TCP nor UDP, no match
            return false;
        }
    }

    // Check protocol compatibility
    // If flow specifies TCP protocol (e.g., RAZE) but packet is UDP, no match
    if (flow.protocol.communication == CommunicationProtocol::TCP && !packet.isPacketOfType(pcpp::TCP)) {
        return false;
    }
    if (flow.protocol.communication == CommunicationProtocol::UDP && !packet.isPacketOfType(pcpp::UDP)) {
        return false;
    }

    return true;
}

// Helper - match TCP connection against a specific flow
bool FlowClassifier::matchesConnection(const pcpp::ConnectionData& conn, const Flow& flow) const {
    // Check IP addresses
    if (!flow.src_ip.empty() && conn.srcIP.toString() != flow.src_ip) {
        return false;
    }
    if (!flow.dst_ip.empty() && conn.dstIP.toString() != flow.dst_ip) {
        return false;
    }

    // Check ports
    if (flow.src_port != 0 && conn.srcPort != flow.src_port) {
        return false;
    }
    if (flow.dst_port != 0 && conn.dstPort != flow.dst_port) {
        return false;
    }

    // TCP connections should only match flows with TCP protocol
    if (flow.protocol.communication != CommunicationProtocol::TCP &&
        flow.protocol.communication != CommunicationProtocol::UNKNOWN) {
        return false;
    }

    return true;
}

// Classify a packet - returns the first matching flow
const Flow* FlowClassifier::classify(const pcpp::Packet& packet) const {
    for (const Flow* flow : all_flows_) {
        if (matchesPacket(packet, *flow)) {
            return flow;
        }
    }
    return nullptr;
}

// Classify a TCP connection - returns the first matching flow
const Flow* FlowClassifier::classify(const pcpp::ConnectionData& conn) const {
    for (const Flow* flow : all_flows_) {
        if (matchesConnection(conn, *flow)) {
            return flow;
        }
    }
    return nullptr;
}


} // namespace pme 
### END: src/FlowClassifier.cpp ###

### FILE: src/FlowClassifier.h ###
#pragma once

#include <Packet.h>
#include <IPv4Layer.h>
#include <TcpLayer.h>
#include <UdpLayer.h>
#include <TcpReassembly.h>
#include <vector>
#include <memory>

#include "Config.h"

namespace pme {

// Forward declaration
struct Flow;

// Keep FlowType enum for backward compatibility with PacketProcessor
// TODO: Eventually remove this when PacketProcessor is fully refactored
enum class FlowType : size_t {
    INGRESS = 0,
    EGRESS = 1,
    NONE = 2
};

// For array sizing - number of valid flow types (excluding NONE)
constexpr size_t FLOW_TYPE_COUNT = 2;

// Helper to get FlowType from a Flow pointer (for backward compatibility)
inline FlowType getFlowType(const Flow* flow) {
    if (!flow) return FlowType::NONE;
    return (flow->direction == FlowDirection::INGRESS) ? FlowType::INGRESS : FlowType::EGRESS;
}

/**
 * FlowClassifier matches packets to specific Flow objects from the configuration.
 * Instead of just returning INGRESS/EGRESS, it returns the exact Flow that matches.
 * This allows the packet processor to use flow-specific settings (protocol, etc).
 */
class FlowClassifier {
public:
    /**
     * Initialize with all flows from the configuration.
     * Builds an internal list of all flows for efficient matching.
     */
    FlowClassifier(const AppConfig& config);

    /**
     * Classify a packet and return the matching Flow.
     * @param packet The packet to classify
     * @return Pointer to the matching Flow, or nullptr if no match
     */
    const Flow* classify(const pcpp::Packet& packet) const;

    /**
     * Classify a TCP connection and return the matching Flow.
     * @param conn The TCP connection data
     * @return Pointer to the matching Flow, or nullptr if no match
     */
    const Flow* classify(const pcpp::ConnectionData& conn) const;

private:
    // Helper methods
    bool matchesPacket(const pcpp::Packet& packet, const Flow& flow) const;
    bool matchesConnection(const pcpp::ConnectionData& conn, const Flow& flow) const;

    // Store all flows in a flat vector for efficient matching
    // Note: These are pointers to flows owned by flow_sets_
    std::vector<const Flow*> all_flows_;
    
    // Keep the flow sets alive (they own the Flow objects)
    std::vector<FlowSet> flow_sets_;
};

} // namespace pme 
### END: src/FlowClassifier.h ###

### FILE: src/IProtocolHandler.h ###
#pragma once

#include <vector>
#include <cstdint>
#include <memory>
#include <unordered_map>
#include <ctime>
#include "ParsedPacketInfo.h"
#include "DropcopyHandler.h"
#include "Log.h"

namespace pme {

// Forward declarations
struct ParsedPacketInfo;

// Protocol context passed to handlers
struct ProtocolContext {
    const std::unordered_map<uint64_t, LatencyStats>& dropcopy_map_ref;
    px::Log* log;
    uint64_t& last_udp_seq;
    
    // Statistics
    struct {
        uint64_t spcast_v3_messages = 0;
        uint64_t raze_messages = 0;
        uint64_t total_messages = 0;
    } stats;
    
    // Helper for consistent hash generation
    static uint64_t generateHash(uint64_t seq, uint64_t recv, uint64_t send);
};

// Parsed message from protocol handler
struct ParsedMessage {
    uint64_t join_key;      // Key for matching ingress/egress packets
    ParsedPacketInfo info;  // Packet information (already contains timestamp)
};

// Interface for protocol-specific message parsing
class IProtocolHandler {
public:
    virtual ~IProtocolHandler() = default;
    
    /**
     * Parse messages from payload bytes
     * @param payload Raw payload data
     * @param payload_size Size of payload
     * @param messages Output vector of parsed messages (cleared before use)
     * @param packet_timestamp Precise timestamp from the packet/stream
     * @param protocol_context Shared context for dropcopy map access
     * @return true if parsing completed successfully (even if no messages found),
     *         false only on parsing errors (malformed data, invalid protocol, etc.)
     */
    virtual bool getMessages(const uint8_t* payload, 
                           size_t payload_size,
                           std::vector<ParsedMessage>& messages,
                           const timespec& packet_timestamp,
                           ProtocolContext& protocol_context) = 0;
    
    /**
     * Get message length for TCP framing (0 for UDP protocols)
     * @param data Start of potential message
     * @param available_size Available data size
     * @return Message length including header, or 0 if more data needed
     */
    virtual size_t getTcpMessageLength(const uint8_t* data, size_t available_size) const {
        return 0; // Default for UDP protocols
    }
    
    /**
     * Get protocol name for logging
     */
    virtual const char* getProtocolName() const = 0;
};

// Factory function to create protocol handlers
std::unique_ptr<IProtocolHandler> createProtocolHandler(MessageProtocol protocol);

} // namespace pme 
### END: src/IProtocolHandler.h ###

### FILE: src/OutputFileWriter.h ###
#pragma once

#include <algorithm>
#include <chrono>
#include <cstdint>
#include <fstream>
#include <iomanip>
#include <string>
#include <unordered_map>
#include <vector>
#include <array>

#include "Log.h"
#include "PacketProcessor.h"  // For JoinedPackets
#include "ParsedPacketInfo.h"  // For ParsedPacketInfo struct
#include "FlowClassifier.h"    // For FLOW_TYPE_COUNT

namespace pme {

namespace OutputFileWriter
{
    bool writeFlowSet(
        const std::vector<JoinedPackets>& joinedPackets,
        const std::string& flowSetName,
        const std::string& outputDir) {
        
        // Construct the output file path
        std::string filename = outputDir + flowSetName + "_results.csv";
        
        // Open the file for writing
        std::ofstream csvFile(filename);
        if (!csvFile.is_open()) {
            return false;
        }
        
        // Write CSV header
        csvFile << "entry_index,ingress_timestamp_ns,egress_timestamp_ns,latency_ns\n";
        
        // Process each joined packet
        size_t index = 0;
        for (const auto& joined : joinedPackets) {
            // Get timestamps directly (already in nanoseconds)
            uint64_t ingressNanos = joined.ingress_packet.timestamp_ns;
            uint64_t egressNanos = joined.egress_packet.timestamp_ns;
            
            // Calculate the latency in nanoseconds
            int64_t latencyNanos = static_cast<int64_t>(egressNanos) - static_cast<int64_t>(ingressNanos);
            
            // Write the data
            csvFile << index++ << "," 
                    << ingressNanos << "," 
                    << egressNanos << "," 
                    << latencyNanos << "\n";
        }
        
        // Check if writing was successful
        if (csvFile.fail()) {
            csvFile.close();
            return false;
        }
        
        csvFile.close();
        return true;
    }
    
    // Legacy function for backward compatibility (if needed)
    bool write(
        const std::unordered_map<uint64_t, std::array<ParsedPacketInfo, FLOW_TYPE_COUNT>>& packetMap,
        const std::string& outputDir) {
        
        // Construct the output file path
        std::string filename = outputDir;
        if (!filename.empty() && filename.back() != '/' && filename.back() != '\\') {
            filename += "/";
        }
        filename += "timestamp_deltas.csv";
        
        // Open the file for writing
        std::ofstream csvFile(filename);
        if (!csvFile.is_open()) {
            return false;
        }
        
        // Write CSV header
        csvFile << "entry_id,timestamp1,timestamp2,delta_nanoseconds\n";
        
        // Process each entry in the map
        for (const auto& [key, packetArray] : packetMap) {
            // Check if both packets are valid
            if (!packetArray[0].isValid() || !packetArray[1].isValid()) {
                continue;
            }
            
            // Get timestamps from both packets (index 0 = INGRESS, index 1 = EGRESS)
            auto timestamp1 = packetArray[0].getTimeStamp();
            auto timestamp2 = packetArray[1].getTimeStamp();
            
            // Convert both timestamps to nanoseconds since epoch
            auto nanos1 = std::chrono::duration_cast<std::chrono::nanoseconds>(
                timestamp1.time_since_epoch()
            ).count();
            auto nanos2 = std::chrono::duration_cast<std::chrono::nanoseconds>(
                timestamp2.time_since_epoch()
            ).count();
            
            // Calculate the delta in nanoseconds (timestamp2 >= timestamp1 guaranteed)
            uint64_t deltaNanos = nanos2 - nanos1;
            csvFile << key << "," << nanos1 << "," << nanos2 << "," << deltaNanos << "\n";
        }
        
        // Check if writing was successful
        if (csvFile.fail()) {
            csvFile.close();
            return false;
        }
        
        csvFile.close();
        return true;
    }
}

} // namespace pme
### END: src/OutputFileWriter.h ###

### FILE: src/PacketProcessor.cpp ###
#include "PacketProcessor.h"
#include "Log.h"
#include <PcapFileDevice.h>
#include <SystemUtils.h>
#include <Packet.h>
#include <IPv4Layer.h>
#include <TcpLayer.h>
#include <UdpLayer.h>
#include <chrono>
#include <algorithm>
#include "FlowClassifier.h"
#include "IProtocolHandler.h"
#include "DropcopyHandler.h"


namespace pme {

px::Log* PacketProcessor::getLogger() {
    static px::Log* logger = PME_GET_LOGGER("PacketProcessor");
    return logger;
}

PacketProcessor::PacketProcessor(std::shared_ptr<RuntimeContext> ctx,
                               const AppConfig& config)
    : log_(getLogger()),
      tcp_reassembly_(
          onTcpMessageReadyCallback,
          this,
          onTcpConnectionStartCallback,
          onTcpConnectionEndCallback
      ),
      ctx_(ctx),
      config_(config),
      flow_classifier_(config)
{
    // Simple initialization - handlers are created on demand
}

PacketProcessor::~PacketProcessor() {
}

IProtocolHandler* PacketProcessor::getOrCreateHandler(const Flow* flow) {
    if (!flow) return nullptr;
    
    auto& handler = flow_handlers_[flow];
    if (!handler) {
        handler = createProtocolHandler(flow->protocol.message);
    }
    return handler.get();
}

// TCP connection lifecycle callbacks
void PacketProcessor::onTcpConnectionStartCallback(const pcpp::ConnectionData& connectionData, void* userCookie) {
    PacketProcessor* self = static_cast<PacketProcessor*>(userCookie);
    if (!self) return;
    
    uint32_t flow_id = connectionData.flowKey;
    
    // Reset flow buffer for new connection
    self->flow_buffers_[flow_id].reset();
}

void PacketProcessor::onTcpConnectionEndCallback(const pcpp::ConnectionData& connectionData, 
                                                  pcpp::TcpReassembly::ConnectionEndReason reason, 
                                                  void* userCookie) {
    PacketProcessor* self = static_cast<PacketProcessor*>(userCookie);
    if (!self) return;
    
    uint32_t flow_id = connectionData.flowKey;
    
    // Check for unprocessed data before removing
    auto it = self->flow_buffers_.find(flow_id);
    if (it != self->flow_buffers_.end()) {
        if (it->second.available_data() > 0) {
            PME_LOG_WARN(self->log_, "TCP Connection Ended for flow key: " << flow_id 
                         << " with " << it->second.available_data() << " bytes unprocessed"
                         << " (total written: " << it->second.getBytesWritten()
                         << ", max buffer size: " << it->second.getMaxSizeReached() << ")");
        }
        self->flow_buffers_.erase(it);
    }
}

void PacketProcessor::onTcpMessageReadyCallback(int8_t side, const pcpp::TcpStreamData& tcpData, void* userCookie) {
    PacketProcessor* self = static_cast<PacketProcessor*>(userCookie);
    if (!self) {
        PME_LOG_ERROR(PME_GET_LOGGER("PacketProcessor"), "TCP MessageReady callback: userCookie is null.");
        return;
    }
    
    uint32_t flow_id = tcpData.getConnectionData().flowKey;
    
    // Classify the TCP connection to find which flow it belongs to
    const Flow* flow = self->flow_classifier_.classify(tcpData.getConnectionData());
    
    if (!flow) {
        return;  // No matching flow, ignore this connection
    }
    
    self->processTcpFlowData(flow_id, tcpData);
}

void PacketProcessor::processTcpFlowData(uint32_t flow_id, const pcpp::TcpStreamData& tcpData) {
    auto& buffer = flow_buffers_[flow_id];
    
    // Write new data to flow buffer
    const uint8_t* new_data = tcpData.getData();
    size_t new_len = tcpData.getDataLength();
    
    if (new_data && new_len > 0) {
        buffer.write(new_data, new_len);
        // Buffer will grow as needed - no data loss
    }
    
    // Classify connection to get flow
    const Flow* flow = flow_classifier_.classify(tcpData.getConnectionData());
    if (!flow) {
        return;
    }
    
    IProtocolHandler* handler = getOrCreateHandler(flow);
    if (!handler) {
        PME_LOG_ERROR(log_, "Failed to create handler for flow protocol: " 
                      << messageProtocolToString(flow->protocol.message));
        return;
    }
    
    // Process messages from buffer
    while (buffer.available_data() > 0) {
        auto [data_ptr, contiguous_size] = buffer.get_contiguous_data();
        if (contiguous_size == 0) {
            break;
        }

        size_t message_len = handler->getTcpMessageLength(data_ptr, contiguous_size);
        if (message_len == 0 || message_len > buffer.available_data()) {
            break;  // Need more data
        }

        processMessages(handler, data_ptr, message_len, 
                       tcpData.getTimeStampPrecise(), 
                       flow->direction, flow);
        
        buffer.consume(message_len);
    }
}

void PacketProcessor::processMessages(IProtocolHandler* handler,
                                     const uint8_t* data,
                                     size_t data_size,
                                     const timespec& timestamp,
                                     FlowDirection direction,
                                     const Flow* flow) {
    if (!handler || !data || data_size == 0) {
        PME_LOG_ERROR(log_, "Invalid parameters for processMessages");
        return;
    }
    
    std::vector<ParsedMessage> messages;
    if (!handler->getMessages(data, data_size, messages, timestamp, protocol_context_)) {
        PME_LOG_DEBUG(log_, "No messages parsed from " << handler->getProtocolName() 
                      << " data of size " << data_size);
        return;
    }
    
    for (const auto& msg : messages) {
        if (direction == FlowDirection::INGRESS) {
            ingress_packets_[msg.join_key] = msg.info;
        } else {  // EGRESS
            auto it = ingress_packets_.find(msg.join_key);
            if (it != ingress_packets_.end()) {
                JoinedPackets joined;
                joined.ingress_packet = it->second;
                joined.egress_packet = msg.info;
                joined.flow_set_name = flow->parent_set;
                results_[flow->parent_set].push_back(joined);
                ingress_packets_.erase(it);
            } else {
                PME_LOG_DEBUG(log_, "Egress message with key " << msg.join_key 
                             << " has no matching ingress packet");
            }
        }
    }
}

size_t PacketProcessor::cleanupExpiredIngressPackets() {
    auto now = std::chrono::steady_clock::now();
    auto now_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(
        now.time_since_epoch()).count();
    
    size_t removed = 0;
    for (auto it = ingress_packets_.begin(); it != ingress_packets_.end();) {
        if (now_ns - it->second.timestamp_ns > INGRESS_PACKET_TIMEOUT_NS) {
            it = ingress_packets_.erase(it);
            removed++;
        } else {
            ++it;
        }
    }
    
    if (removed > 0) {
        PME_LOG_INFO(log_, "Cleaned up " << removed << " expired ingress packets");
    }
    
    return removed;
}

// Process packet with explicit Flow object
void PacketProcessor::handlePacket(pcpp::Packet& packet, const Flow* flow) {
    if (!flow) {
        return;
    }
    
    if (packet.isPacketOfType(pcpp::UDP)) {
        pcpp::UdpLayer* udpLayer = packet.getLayerOfType<pcpp::UdpLayer>();
        if (!udpLayer) {
            PME_LOG_ERROR(log_, "handlePacket called on UDP packet without UDP layer");
            return;
        }
        
        uint8_t* payload = udpLayer->getLayerPayload();
        size_t payloadSize = udpLayer->getLayerPayloadSize();
        
        if (payloadSize == 0) {
            return;  // Empty payload, nothing to process
        }
        
        IProtocolHandler* handler = getOrCreateHandler(flow);
        if (!handler) {
            PME_LOG_ERROR(log_, "Failed to create handler for flow protocol: " 
                          << messageProtocolToString(flow->protocol.message));
            return;
        }
        
        processMessages(handler, payload, payloadSize,
                       packet.getRawPacket()->getPacketTimeStamp(),
                       flow->direction, flow);
                       
    } else if (packet.isPacketOfType(pcpp::TCP)) {
        // For TCP, just pass to reassembly
        pcpp::TcpLayer* tcpLayer = packet.getLayerOfType<pcpp::TcpLayer>();
        pcpp::IPv4Layer* ipv4Layer = packet.getLayerOfType<pcpp::IPv4Layer>();
        
        if (tcpLayer && ipv4Layer) {
            tcp_reassembly_.reassemblePacket(packet);
        }
    }
}

PacketProcessor::BufferStats PacketProcessor::getBufferStats() const {
    BufferStats stats;
    
    for (const auto& [flow_id, buffer] : flow_buffers_) {
        stats.total_bytes_written += buffer.getBytesWritten();
        stats.max_buffer_size = std::max(stats.max_buffer_size, buffer.getMaxSizeReached());
    }
    
    stats.active_flows = flow_buffers_.size();
    
    return stats;
}

// Main processing function
std::unordered_map<std::string, std::vector<JoinedPackets>> PacketProcessor::processFile(const std::string& filePath) {
    // Clear all state
    ingress_packets_.clear();
    results_.clear();
    
    // Refresh dropcopy data for this file processing
    DropcopyHandler dc(config_.dropcopy_path);
    protocol_context_ = {dc.getMapRef(), log_, last_udpseq_};
    
    std::unique_ptr<pcpp::IFileReaderDevice> reader(pcpp::IFileReaderDevice::getReader(filePath));
    if (!reader || !reader->open()) {
        PME_LOG_ERROR(log_, "Cannot open PCAP file: " << filePath);
        return {};
    }
    
    // Clean up any existing state
    tcp_reassembly_.closeAllConnections();
    flow_buffers_.clear();
    
    // Process packets
    pcpp::RawPacket rawPacket;
    int packetCount = 0;
    int ingressCount = 0;
    int egressCount = 0;
    int ignoredCount = 0;
    
    while (reader->getNextPacket(rawPacket)) {
        if (ctx_->stop.load()) {
            break;
        }
        
        packetCount++;
        pcpp::Packet parsedPacket(&rawPacket);
        
        // Classify packet to specific flow
        const Flow* flow = flow_classifier_.classify(parsedPacket);

        if (!flow) {
            ignoredCount++;
            continue;
        }

        if (flow->direction == FlowDirection::INGRESS) {
            ingressCount++;
        } else {
            egressCount++;
        }

        // Process packet with the matched flow
        handlePacket(parsedPacket, flow);
        
        // Cleanup expired packets periodically
        if (packetCount % 2000 == 0) {
            cleanupExpiredIngressPackets();
        }
    }
    
    // Final cleanup
    tcp_reassembly_.closeAllConnections();
    flow_buffers_.clear();
    
    // Get buffer statistics before cleanup
    BufferStats buffer_stats = getBufferStats();
    
    PME_LOG_INFO(log_, "Processed " << filePath 
                       << " - Total: " << packetCount
                       << ", Ingress: " << ingressCount
                       << ", Egress: " << egressCount
                       << ", Ignored: " << ignoredCount
                       << ", SPCastV3: " << protocol_context_.stats.spcast_v3_messages
                       << ", Raze: " << protocol_context_.stats.raze_messages);
    
    if (buffer_stats.max_buffer_size > DEFAULT_BUFFER_SIZE) {
        PME_LOG_INFO(log_, "Buffer Statistics - Active flows: " << buffer_stats.active_flows
                          << ", Max buffer size reached: " << buffer_stats.max_buffer_size
                          << " bytes (initial: " << DEFAULT_BUFFER_SIZE << ")");
    }
    
    reader->close();
    
    // Log any remaining unmatched ingress packets
    if (!ingress_packets_.empty()) {
        PME_LOG_WARN(log_, "File processing complete with " << ingress_packets_.size() 
                     << " unmatched ingress packets");
    }
    
    // Return the results
    return results_;
}

} // namespace pme

### END: src/PacketProcessor.cpp ###

### FILE: src/PacketProcessor.h ###
#pragma once

#include <cassert>
#include <chrono>
#include <cstdint>
#include <cstring>
#include <memory>
#include <string>
#include <unordered_map>
#include <utility>
#include <vector>
#include <array>
#include <deque>
#include <mutex>
#include <condition_variable>
#include <atomic>

#include <PcapFileDevice.h>
#include <Packet.h>
#include <TcpReassembly.h>
#include <boost/functional/hash.hpp>
#include "Log.h"

#include "DropcopyHandler.h"
#include "RuntimeContext.h"
#include "ParsedPacketInfo.h"
#include "Config.h"
#include "FlowClassifier.h"
#include "IProtocolHandler.h"

namespace pme {

// Configuration constants
static constexpr size_t DEFAULT_BUFFER_SIZE = 65536;  // 64KB
static constexpr uint64_t INGRESS_PACKET_TIMEOUT_NS = 5'000'000'000;  // 5 seconds

// Joined packets containing both ingress and egress info
struct JoinedPackets {
    ParsedPacketInfo ingress_packet;
    ParsedPacketInfo egress_packet;
    std::string flow_set_name;  // Which flow set this belongs to
};

// Growing buffer that dynamically expands to never drop data
class FlowBuffer {
private:
    std::vector<uint8_t> buffer_;
    size_t write_pos_ = 0;
    size_t read_pos_ = 0;
    
    // Statistics for monitoring
    std::atomic<uint64_t> bytes_written_{0};
    std::atomic<size_t> max_size_reached_{DEFAULT_BUFFER_SIZE};
    
public:
    FlowBuffer() {
        buffer_.reserve(DEFAULT_BUFFER_SIZE);
    }
    
    size_t available_data() const {
        return write_pos_ - read_pos_;
    }
    
    // Get statistics
    uint64_t getBytesWritten() const { return bytes_written_.load(); }
    size_t getMaxSizeReached() const { return max_size_reached_.load(); }
    
    // Write data into buffer - always succeeds
    void write(const uint8_t* data, size_t len) {
        if (len == 0) return;
        
        // Ensure we have enough space
        size_t needed_size = write_pos_ + len;
        if (needed_size > buffer_.size()) {
            // Need to grow buffer
            size_t new_size = buffer_.empty() ? std::max(DEFAULT_BUFFER_SIZE, len) 
                                              : std::max(buffer_.size() * 2, needed_size);
            growBuffer(new_size);
        }
        
        // Check if we need to compact to prevent positions from overflowing
        if (read_pos_ > 1000000 && read_pos_ == write_pos_) {
            // Buffer is empty and positions are high - reset
            read_pos_ = 0;
            write_pos_ = 0;
        }
        
        // Write data
        std::memcpy(buffer_.data() + write_pos_, data, len);
        write_pos_ += len;
        bytes_written_ += len;
        
        // Track maximum size
        size_t current_size = buffer_.size();
        size_t max_size = max_size_reached_.load();
        while (current_size > max_size && 
               !max_size_reached_.compare_exchange_weak(max_size, current_size)) {
            // Keep trying until we update max size
        }
    }
    
    // Get pointer to contiguous readable data (always contiguous in our design)
    std::pair<const uint8_t*, size_t> get_contiguous_data() const {
        size_t avail = available_data();
        if (avail == 0) return {nullptr, 0};
        return {buffer_.data() + read_pos_, avail};
    }
    
    // Consume data
    void consume(size_t len) {
        len = std::min(len, available_data());
        read_pos_ += len;
        
        // Optional: Reset positions when buffer is empty to prevent eventual overflow.
        // Since we're not using modulo operations (not a true ring buffer), positions
        // would overflow after ~4GB on 32-bit or ~16EB on 64-bit systems.
        // This reset is a safety measure, though overflow is unlikely in practice.
        if (read_pos_ == write_pos_ && read_pos_ > 1000000) {
            read_pos_ = 0;
            write_pos_ = 0;
        }
    }
    
    void reset() {
        write_pos_ = 0;
        read_pos_ = 0;
        // Keep the allocated buffer to avoid reallocation
    }
    
private:
    void growBuffer(size_t new_size) {
        buffer_.resize(new_size);
    }
};

/**
 * PacketProcessor - Processes PCAP files to match ingress/egress packets
 * 
 * Thread Safety: This class is designed for single-threaded operation.
 * - The processFile() method should be called from a single worker thread
 * - The main thread typically waits for interrupt signals
 * - No internal locking is performed
 * 
 * Memory Management:
 * - Ingress packets are stored temporarily until matched with egress
 * - Unmatched packets are cleaned up after INGRESS_PACKET_TIMEOUT_NS (5 seconds)
 * - TCP flow buffers grow dynamically but are cleaned up when connections end
 */
class PacketProcessor {
public:
    PacketProcessor(std::shared_ptr<RuntimeContext> ctx,
                    const AppConfig& config);
    ~PacketProcessor();
    
    // Process file and return join vectors for each flow set
    std::unordered_map<std::string, std::vector<JoinedPackets>> processFile(const std::string& filePath);
    
    /**
     * Get protocol statistics after processing.
     * @return The protocol context statistics
     */
    const ProtocolContext& getProtocolContext() const { return protocol_context_; }
    
    /**
     * Get buffer statistics for monitoring
     */
    struct BufferStats {
        uint64_t total_bytes_written = 0;
        size_t active_flows = 0;
        size_t max_buffer_size = 0;
    };
    
    BufferStats getBufferStats() const;
    
    /**
     * Clean up old unmatched ingress packets
     * @return Number of packets cleaned up
     */
    size_t cleanupExpiredIngressPackets();
    
private:
    // TCP Reassembly callbacks
    static void onTcpMessageReadyCallback(int8_t side, const pcpp::TcpStreamData& tcpData, void* userCookie);
    static void onTcpConnectionStartCallback(const pcpp::ConnectionData& connectionData, void* userCookie);
    static void onTcpConnectionEndCallback(const pcpp::ConnectionData& connectionData, 
                                          pcpp::TcpReassembly::ConnectionEndReason reason, void* userCookie);
    
    // Protocol processing
    void processTcpFlowData(uint32_t flow_id, const pcpp::TcpStreamData& tcpData);
    void handlePacket(pcpp::Packet& packet, const Flow* flow);
    
    // Helper to get or create protocol handler for a flow
    IProtocolHandler* getOrCreateHandler(const Flow* flow);
    
    px::Log* log_;
    pcpp::TcpReassembly tcp_reassembly_;
    std::unordered_map<uint32_t, FlowBuffer> flow_buffers_;  // Flow buffers per connection
    
    std::shared_ptr<RuntimeContext> ctx_;
    AppConfig config_;
    
    // Simplified data structures
    std::unordered_map<uint64_t, ParsedPacketInfo> ingress_packets_;  // Ingress packets waiting for match
    std::unordered_map<const Flow*, std::unique_ptr<IProtocolHandler>> flow_handlers_;  // Direct flow->handler mapping
    std::unordered_map<std::string, std::vector<JoinedPackets>> results_;  // Results per flow set
    
    uint64_t last_udpseq_ {0};
    ProtocolContext protocol_context_;
    
    // Flow classification helper
    FlowClassifier flow_classifier_;
    
    // Unified message processing
    void processMessages(IProtocolHandler* handler,
                        const uint8_t* data,
                        size_t data_size,
                        const timespec& timestamp,
                        FlowDirection direction,
                        const Flow* flow);
    
    static px::Log* getLogger();
};

} // namespace pme

### END: src/PacketProcessor.h ###

### FILE: src/ParsedPacketInfo.h ###
#pragma once
#include <chrono>
#include <cstdint>

struct ParsedPacketInfo
{
    uint64_t timestamp_ns = 0;  // Timestamp in nanoseconds since epoch
    
    ParsedPacketInfo() = default;
    
    ParsedPacketInfo(uint64_t timestamp)
        : timestamp_ns(timestamp) {}
    
    // For backward compatibility
    std::chrono::time_point<std::chrono::high_resolution_clock> getTimeStamp() const 
    {
        auto ns = std::chrono::nanoseconds(timestamp_ns);
        return std::chrono::time_point<std::chrono::high_resolution_clock>(
            std::chrono::duration_cast<std::chrono::high_resolution_clock::duration>(ns)
        );
    }
    
    bool isValid() const { return timestamp_ns != 0; }
};
### END: src/ParsedPacketInfo.h ###

### FILE: src/ProtocolHandlerFactory.cpp ###
#include "IProtocolHandler.h"
#include "SpcastV3Handler.h"
#include "RazeHandler.h"
#include <stdexcept>

namespace pme {

// Helper implementation for hash generation
uint64_t ProtocolContext::generateHash(uint64_t seq, uint64_t recv, uint64_t send) {
        std::size_t seed = 0;
        boost::hash_combine(seed, seq);
        boost::hash_combine(seed, recv);
        boost::hash_combine(seed, send);
        return static_cast<uint64_t>(seed);
}

std::unique_ptr<IProtocolHandler> createProtocolHandler(MessageProtocol protocol) {
    switch (protocol) {
        case MessageProtocol::SPCAST_V3:
            return std::make_unique<SpcastV3Handler>();
        case MessageProtocol::RAZE:
            return std::make_unique<RazeHandler>();
        default:
            throw std::runtime_error("Unknown protocol type");
    }
}

} // namespace pme 
### END: src/ProtocolHandlerFactory.cpp ###

### FILE: src/Protocols.h ###
#pragma once

#include <md_api/proto/spcast_v3.h>
#include <md_api/proto/spcast_v4.h>
#include <razeapi/messages/raze.hpp>
#include <razeapi/messages/xraze.hpp>
#include <string>
#include <algorithm>
#include <cctype>

namespace spcast {
    namespace SpcastVersion3Traits {
        using PacketHeader = md_api::proto::spcast_v3::packet_header_t;
        using MessageHeader = md_api::proto::spcast_v3::message_header_t;
    };
    
    namespace SpcastVersion4Traits {
        using PacketHeader = md_api::proto::spcast_v4::packet_header_t;
        using MessageHeader = md_api::proto::spcast_v4::message_header_t;
    };
}

namespace RazeFormatter {
    using Header = xraze::header;
    using UnsequencedHeader = ::raze::unsequenced_header;
    using NewOrder = ::raze::new_order;
    using MessageType = ::raze::message_type_e;
    using PacketType = xraze::packet_type_e;
}

namespace pme {

enum class CommunicationProtocol {
    UNKNOWN,
    TCP,
    UDP
};

enum class MessageProtocol {
    UNKNOWN,
    SPCASTV3,
    RAZE,
};

// Helper functions to convert strings to enums
inline CommunicationProtocol stringToCommunicationProtocol(const std::string& str) {
    std::string lower = str;
    std::transform(lower.begin(), lower.end(), lower.begin(), ::tolower);
    
    if (lower == "tcp") return CommunicationProtocol::TCP;
    if (lower == "udp") return CommunicationProtocol::UDP;
    return CommunicationProtocol::UNKNOWN;
}

inline MessageProtocol stringToMessageProtocol(const std::string& str) {
    std::string lower = str;
    std::transform(lower.begin(), lower.end(), lower.begin(), ::tolower);
    
    if (lower == "spcastv3") return MessageProtocol::SPCASTV3;
    if (lower == "raze") return MessageProtocol::RAZE;
    return MessageProtocol::UNKNOWN;
}

// Helper functions to convert enums to strings (for debugging/logging)
inline std::string communicationProtocolToString(CommunicationProtocol proto) {
    switch (proto) {
        case CommunicationProtocol::TCP: return "TCP";
        case CommunicationProtocol::UDP: return "UDP";
        default: return "UNKNOWN";
    }
}

inline std::string messageProtocolToString(MessageProtocol proto) {
    switch (proto) {
        case MessageProtocol::SPCASTV3: return "SPCASTV3";
        case MessageProtocol::RAZE: return "RAZE";
        default: return "UNKNOWN";
    }
}

struct Protocol {
    CommunicationProtocol communication = CommunicationProtocol::UNKNOWN;
    MessageProtocol message = MessageProtocol::UNKNOWN;

    bool is_valid() const {
        return communication != CommunicationProtocol::UNKNOWN && 
               message != MessageProtocol::UNKNOWN;
    }
    
    std::string toString() const {
        return communicationProtocolToString(communication) + "/" + 
               messageProtocolToString(message);
    }
};

} // namespace pme
### END: src/Protocols.h ###

### FILE: src/RazeHandler.cpp ###
#include "RazeHandler.h"
#include <cstring>
#include "Log.h"
#include "Protocols.h"

namespace pme {

// No need to define our own structs - use the ones from Protocols.h
// RazeFormatter::Header
// RazeFormatter::UnsequencedHeader  
// RazeFormatter::NewOrder

size_t RazeHandler::getTcpMessageLength(const uint8_t* data, size_t available_size) const {
    if (available_size < sizeof(RazeFormatter::Header)) {
        return 0;  // Need more data
    }
    
    const auto* header = reinterpret_cast<const RazeFormatter::Header*>(data);
    
    // RazeFormatter header has packet_length field
    uint16_t message_len = header->packet_length;
    
    if (message_len == 0) {
        return 0;  // Invalid length
    }
    
    return message_len;  // Total bytes needed for this message
}

bool RazeHandler::getMessages(const uint8_t* payload, 
                              size_t payload_size,
                              std::vector<ParsedMessage>& messages,
                              const timespec& packet_timestamp,
                              ProtocolContext& protocol_context) {
    messages.clear();
    
    if (payload_size < sizeof(RazeFormatter::Header)) {
        return false;
    }
    
    const auto* hdr = reinterpret_cast<const RazeFormatter::Header*>(payload);
    
    // Check packet type - we're interested in unsequenced_data
    if (hdr->packet_type != RazeFormatter::PacketType::unsequenced_data) {
        return true;  // Valid packet, just not the type we process
    }
    
    // For unsequenced data, we need to check if it's a new_order
    if (payload_size < sizeof(RazeFormatter::UnsequencedHeader)) {
        return false;
    }
    
    const auto* unseq_hdr = reinterpret_cast<const RazeFormatter::UnsequencedHeader*>(payload);
    
    if (unseq_hdr->message_type != RazeFormatter::MessageType::new_order) {
        return true;  // Valid message, just not new_order
    }
    
    // Now we know it's a new_order message
    if (payload_size < sizeof(RazeFormatter::NewOrder)) {
        return false;
    }
    
    const auto* new_order = reinterpret_cast<const RazeFormatter::NewOrder*>(payload);
    
    // Look up in dropcopy map using order_token
    auto it = protocol_context.dropcopy_map_ref.find(static_cast<uint64_t>(new_order->data.order_token));
    if (it != protocol_context.dropcopy_map_ref.end()) {
        const auto& stat = it->second;
        
        // Create parsed message
        ParsedMessage msg;
        msg.join_key = ProtocolContext::generateHash(stat.md_seq_num, stat.md_recv_time, stat.md_send_time);
        msg.info.timestamp_ns = static_cast<uint64_t>(packet_timestamp.tv_sec) * 1'000'000'000ULL + packet_timestamp.tv_nsec;
        
        messages.push_back(msg);
        
        protocol_context.stats.raze_messages++;
        protocol_context.stats.total_messages++;
    } else {
        PME_LOG_WARN(protocol_context.log, "Order token " << new_order->data.order_token << " not found in dropcopy map");
    }
    
    return true;
}

} // namespace pme 
### END: src/RazeHandler.cpp ###

### FILE: src/RazeHandler.h ###
#pragma once

#include "IProtocolHandler.h"
#include <cstdint>

namespace pme {

class RazeHandler : public IProtocolHandler {
public:
    RazeHandler() = default;
    virtual ~RazeHandler() = default;
    
    bool getMessages(const uint8_t* payload, 
                    size_t payload_size,
                    std::vector<ParsedMessage>& messages,
                    const timespec& packet_timestamp,
                    ProtocolContext& protocol_context) override;
                    
    size_t getTcpMessageLength(const uint8_t* data, size_t available_size) const override;
    
    const char* getProtocolName() const override {
        return "Raze";
    }
};

} // namespace pme 
### END: src/RazeHandler.h ###

### FILE: src/RuntimeContext.h ###
#pragma once

#include <atomic>
#include <memory>

namespace pme {

struct RuntimeContext
{
    std::atomic<bool> stop{false};
};

} // namespace pme

### END: src/RuntimeContext.h ###

### FILE: src/SpcastV3Handler.cpp ###
#include "SpcastV3Handler.h"
#include <cstring>
#include "Log.h"
#include "Protocols.h"

namespace pme {

// No need to define our own structs - use the ones from Protocols.h
// spcast::SpcastVersion3Traits::PacketHeader
// spcast::SpcastVersion3Traits::MessageHeader

bool SpcastV3Handler::getMessages(const uint8_t* payload, 
                                  size_t payload_size,
                                  std::vector<ParsedMessage>& messages,
                                  const timespec& packet_timestamp,
                                  ProtocolContext& protocol_context) {
    messages.clear();
    
    // Need at least packet header
    if (payload_size < sizeof(spcast::SpcastVersion3Traits::PacketHeader)) {
        PME_LOG_WARN(protocol_context.log, "SPCASTV3: Datagram too small (" << payload_size << " bytes)");
        return false;
    }
    
    const auto* pktHdr = reinterpret_cast<const spcast::SpcastVersion3Traits::PacketHeader*>(payload);
    
    // SPCast V3 first byte is version (should be 3)
    if (pktHdr->version != 3) {
        return false;  // Not SPCast V3
    }
    
    const uint64_t recv_timestamp_ns = pktHdr->recv_timestamp_ns;
    const uint64_t send_timestamp_ns = pktHdr->send_timestamp_ns;
    
    // Process messages in packet
    const uint8_t* cursor = payload + sizeof(spcast::SpcastVersion3Traits::PacketHeader);
    const uint8_t* end = payload + payload_size;
    
    while (cursor + sizeof(spcast::SpcastVersion3Traits::MessageHeader) <= end) {
        const auto* msgHdr = reinterpret_cast<const spcast::SpcastVersion3Traits::MessageHeader*>(cursor);
        uint16_t msg_len = msgHdr->length;
        
        if (msg_len == 0) {
            PME_LOG_WARN(protocol_context.log, "SPCASTV3: Message length 0");
            break;
        }
        
        if (cursor + msg_len > end) {
            PME_LOG_WARN(protocol_context.log, "SPCASTV3: Truncated message");
            break;
        }
        
        uint64_t seq = msgHdr->seq_num;
        
        // Deduplicate by sequence number
        if (seq != protocol_context.last_udp_seq) {
            // Create parsed message
            ParsedMessage msg;
            msg.join_key = ProtocolContext::generateHash(seq, recv_timestamp_ns, send_timestamp_ns);
            msg.info.timestamp_ns = static_cast<uint64_t>(packet_timestamp.tv_sec) * 1'000'000'000ULL + packet_timestamp.tv_nsec;
            
            messages.push_back(msg);
            protocol_context.last_udp_seq = seq;
        }
        
        protocol_context.stats.spcast_v3_messages++;
        protocol_context.stats.total_messages++;
        cursor += msg_len;
    }
    
    return true;  // Parsing completed (even if no messages)
}

} // namespace pme 
### END: src/SpcastV3Handler.cpp ###

### FILE: src/SpcastV3Handler.h ###
#pragma once

#include "IProtocolHandler.h"
#include <cstdint>

namespace pme {

class SpcastV3Handler : public IProtocolHandler {
public:
    SpcastV3Handler() = default;
    virtual ~SpcastV3Handler() = default;
    
    bool getMessages(const uint8_t* payload, 
                    size_t payload_size,
                    std::vector<ParsedMessage>& messages,
                    const timespec& packet_timestamp,
                    ProtocolContext& protocol_context) override;
                    
    const char* getProtocolName() const override {
        return "SPCastV3";
    }
};

} // namespace pme 
### END: src/SpcastV3Handler.h ###

### FILE: src/main.cpp ###
#include <memory>

#include <spapp/logging/logging.hpp>

#include "Cli.h"
#include "Engine.h"
#include "RuntimeContext.h"
#include "Log.h"

int main(int argc, char** argv)
{
    sp::logging::start(sp::logging::stdout_config());
    sp::logging::set_override(sp::logging::level::DEBUG);

    auto config = pme::parse_cli(argc, argv);
    auto ctx = std::make_shared<pme::RuntimeContext>();

    pme::Engine g_engine(ctx, config);
    g_engine.run();

    sp::logging::stop();
    return 0;
}

### END: src/main.cpp ###

### FILE: tests/DropcopyHandler_test.cpp ###
#include "gtest/gtest.h"
#include "../src/DropcopyHandler.h"
#include <fstream>
#include <filesystem>
#include <chrono>

class DropcopyHandlerTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Create temporary directory for test files
        test_dir_ = std::filesystem::temp_directory_path() / "dropcopy_test";
        std::filesystem::create_directories(test_dir_);
    }

    void TearDown() override {
        // Clean up test files
        std::filesystem::remove_all(test_dir_);
    }

    void CreateTestFile(const std::string& filename, const std::string& content) {
        std::ofstream file(test_dir_ / filename);
        file << content;
        file.close();
    }

    std::filesystem::path test_dir_;
};

// Test timestamp parsing
TEST_F(DropcopyHandlerTest, ParseTimestampValid) {
    DropcopyHandler handler("");
    
    // Test full nanosecond precision
    uint64_t result = handler.parseTimestamp("2024-01-15 14:30:45.123456789");
    
    // Verify the result (you may need to adjust expected value)
    // This is 2024-01-15 14:30:45.123456789 UTC in nanoseconds since epoch
    EXPECT_GT(result, 0);
    
    // Test with fewer nanoseconds
    uint64_t result2 = handler.parseTimestamp("2024-01-15 14:30:45.123");
    EXPECT_GT(result2, 0);
    
    // Test without nanoseconds
    uint64_t result3 = handler.parseTimestamp("2024-01-15 14:30:45");
    EXPECT_GT(result3, 0);
}

TEST_F(DropcopyHandlerTest, ParseTimestampEdgeCases) {
    DropcopyHandler handler("");
    
    // Test epoch time
    uint64_t epoch = handler.parseTimestamp("1970-01-01 00:00:00");
    EXPECT_EQ(epoch, 0);
    
    // Test invalid format should return 0
    uint64_t invalid = handler.parseTimestamp("invalid-timestamp");
    EXPECT_EQ(invalid, 0);
}

// Test key-value parsing
TEST_F(DropcopyHandlerTest, ParseKeyValue) {
    DropcopyHandler handler("");
    
    std::string_view text = "key1=value1, key2='quoted value', key3=123";
    size_t pos = 0;
    
    auto [k1, v1] = handler.parseKV(text, pos);
    EXPECT_EQ(k1, "key1");
    EXPECT_EQ(v1, "value1");
    
    auto [k2, v2] = handler.parseKV(text, pos);
    EXPECT_EQ(k2, "key2");
    EXPECT_EQ(v2, "'quoted value'");
    
    auto [k3, v3] = handler.parseKV(text, pos);
    EXPECT_EQ(k3, "key3");
    EXPECT_EQ(v3, "123");
}

// Test full file parsing
TEST_F(DropcopyHandlerTest, ParseDropcopyFile) {
    std::string test_content = R"(
2024-01-15 14:30:45.123 [INFO] Order placed: clordid = 12345 , latency_stats = {event_type=QUOTE, md_seq_num=100, md_feed_name='FEED1', exch_seq_num=200, before_md_recv=2024-01-15 14:30:45.100000000, after_md_recv=2024-01-15 14:30:45.101000000}
2024-01-15 14:30:46.456 [INFO] Order placed: clordid = 67890 , latency_stats = {event_type=TRADE, md_seq_num=101, md_feed_name='FEED2', exch_seq_num=201, before_md_recv=2024-01-15 14:30:46.400000000, after_md_recv=2024-01-15 14:30:46.401000000}
)";
    
    CreateTestFile("test_dropcopy.log", test_content);
    
    DropcopyHandler handler((test_dir_ / "test_dropcopy.log").string());
    auto map = handler.getMapRef();
    
    EXPECT_EQ(map.size(), 2);
    
    // Check first entry
    auto it1 = map.find(12345);
    ASSERT_NE(it1, map.end());
    EXPECT_EQ(it1->second.event_type, "QUOTE");
    EXPECT_EQ(it1->second.md_seq_num, 100);
    EXPECT_EQ(it1->second.md_feed_name, "FEED1");
    
    // Check second entry
    auto it2 = map.find(67890);
    ASSERT_NE(it2, map.end());
    EXPECT_EQ(it2->second.event_type, "TRADE");
    EXPECT_EQ(it2->second.md_seq_num, 101);
    EXPECT_EQ(it2->second.md_feed_name, "FEED2");
}

// Test empty file
TEST_F(DropcopyHandlerTest, ParseEmptyFile) {
    CreateTestFile("empty.log", "");
    
    DropcopyHandler handler((test_dir_ / "empty.log").string());
    auto map = handler.getMapRef();
    
    EXPECT_TRUE(map.empty());
}

// Test malformed entries
TEST_F(DropcopyHandlerTest, ParseMalformedEntries) {
    std::string test_content = R"(
This is not a valid line
clordid = not_a_number , latency_stats = {event_type=QUOTE}
2024-01-15 14:30:45.123 [INFO] Order placed: clordid = 12345 , latency_stats = {malformed
)";
    
    CreateTestFile("malformed.log", test_content);
    
    DropcopyHandler handler((test_dir_ / "malformed.log").string());
    auto map = handler.getMapRef();
    
    // Should skip malformed entries
    EXPECT_EQ(map.size(), 0);
} 
### END: tests/DropcopyHandler_test.cpp ###
