Enhanced PacketParser Implementation
First, let's enhance the PacketParser class to extract all useful header information and provide a clean interface for handling the payload.
PacketParser.h Updates
cppCopy#pragma once

#include "IPacketParser.h"
#include "Log.h"
#include <cstdint>
#include <string>
#include <chrono>
#include <functional>
#include <vector>
#include <netinet/in.h>

/**
 * Parses raw packet data into structured format
 */
class PacketParser : public IPacketParser {
public:
    // Protocol types
    enum class Protocol {
        UNKNOWN,
        IPv4,
        IPv6,
        ARP,
        TCP,
        UDP,
        ICMP,
        OTHER
    };
    
    // IP address structure
    struct IPAddress {
        union {
            uint32_t ipv4;
            uint8_t ipv6[16];
        } addr;
        bool isIPv6;
        
        std::string toString() const;
    };
    
    // Packet information structure - stores all useful header info
    struct PacketInfo {
        // Timestamp
        std::chrono::system_clock::time_point timestamp;
        
        // Layer 2 (Ethernet)
        std::string srcMac;
        std::string dstMac;
        uint16_t etherType;
        
        // Layer 3 (IP)
        Protocol l3Protocol;
        IPAddress srcIP;
        IPAddress dstIP;
        uint8_t ipProtocol;
        
        // Layer 4 (TCP/UDP)
        Protocol l4Protocol;
        uint16_t srcPort;
        uint16_t dstPort;
        uint32_t tcpSeqNum;
        uint32_t tcpAckNum;
        bool tcpSyn;
        bool tcpAck;
        bool tcpFin;
        bool tcpRst;
        
        // Payload information
        const uint8_t* payloadData;
        size_t payloadSize;
    };
    
    // Type definition for payload callback function
    using PayloadCallback = std::function<void(const PacketInfo&, const uint8_t*, size_t)>;
    
    /**
     * Constructor
     */
    PacketParser()
        : m_packetCount(0),
          log_(PME_GET_LOGGER("PacketParser")) {
        PME_LOG_INFO(log_, "PacketParser created");
    }
    
    /**
     * Parse a packet
     * @param packetView View containing packet data
     * @return true if parsing was successful, false otherwise
     */
    bool parse(const PcapPacketIterator::PacketView& packetView) override;
    
    /**
     * Reset parser state before starting a new file
     */
    void reset() override {
        m_packetCount = 0;
        PME_LOG_INFO(log_, "Parser state reset");
    }
    
    /**
     * Get number of packets parsed
     * @return Packet count
     */
    size_t getPacketCount() const {
        return m_packetCount;
    }
    
    /**
     * Set callback for payload processing
     * @param callback Function to call with payload data
     */
    void setPayloadCallback(PayloadCallback callback) {
        m_payloadCallback = callback;
    }
    
    /**
     * Get the last parsed packet info
     * @return Reference to the last parsed packet info
     */
    const PacketInfo& getLastPacketInfo() const {
        return m_lastPacketInfo;
    }
    
private:
    // Helper methods for parsing specific protocols
    bool parseEthernetHeader(const uint8_t* data, size_t dataSize, PacketInfo& info, size_t& offset);
    bool parseIPv4Header(const uint8_t* data, size_t dataSize, PacketInfo& info, size_t& offset);
    bool parseTCPHeader(const uint8_t* data, size_t dataSize, PacketInfo& info, size_t& offset);
    bool parseUDPHeader(const uint8_t* data, size_t dataSize, PacketInfo& info, size_t& offset);
    
    // Format MAC address to string
    std::string formatMacAddress(const uint8_t* mac);
    
    // Count of packets parsed
    size_t m_packetCount;
    
    // Callback for payload processing
    PayloadCallback m_payloadCallback;
    
    // Last parsed packet info
    PacketInfo m_lastPacketInfo;
    
    // Logger
    px::Log* log_;
};
PacketParser.cpp Updates
cppCopy#include "PacketParser.h"
#include <netinet/in.h>  // For ntohs, ntohl
#include <arpa/inet.h>   // For inet_ntoa
#include <sstream>
#include <iomanip>

std::string PacketParser::IPAddress::toString() const {
    if (isIPv6) {
        char buf[INET6_ADDRSTRLEN];
        inet_ntop(AF_INET6, addr.ipv6, buf, INET6_ADDRSTRLEN);
        return std::string(buf);
    } else {
        struct in_addr ipAddr;
        ipAddr.s_addr = addr.ipv4;
        return std::string(inet_ntoa(ipAddr));
    }
}

std::string PacketParser::formatMacAddress(const uint8_t* mac) {
    std::stringstream ss;
    ss << std::hex << std::setfill('0');
    for (int i = 0; i < 6; ++i) {
        ss << std::setw(2) << static_cast<int>(mac[i]);
        if (i < 5) ss << ":";
    }
    return ss.str();
}

bool PacketParser::parseEthernetHeader(const uint8_t* data, size_t dataSize, PacketInfo& info, size_t& offset) {
    if (dataSize < 14) {
        return false;
    }
    
    // Extract MAC addresses
    info.srcMac = formatMacAddress(data + 6);
    info.dstMac = formatMacAddress(data);
    
    // Extract EtherType
    info.etherType = (data[12] << 8) | data[13];
    
    offset = 14;
    return true;
}

bool PacketParser::parseIPv4Header(const uint8_t* data, size_t dataSize, PacketInfo& info, size_t& offset) {
    if (dataSize < 20) {
        return false;
    }
    
    // Get header length (in 32-bit words)
    uint8_t ihl = (data[0] & 0x0F);
    size_t ipHeaderLen = ihl * 4;
    
    if (dataSize < ipHeaderLen) {
        return false;
    }
    
    // Set protocol
    info.l3Protocol = Protocol::IPv4;
    
    // Extract source and destination IP
    info.srcIP.isIPv6 = false;
    info.srcIP.addr.ipv4 = *reinterpret_cast<const uint32_t*>(data + 12);
    
    info.dstIP.isIPv6 = false;
    info.dstIP.addr.ipv4 = *reinterpret_cast<const uint32_t*>(data + 16);
    
    // Extract protocol
    info.ipProtocol = data[9];
    
    offset += ipHeaderLen;
    return true;
}

bool PacketParser::parseTCPHeader(const uint8_t* data, size_t dataSize, PacketInfo& info, size_t& offset) {
    if (dataSize < 20) {
        return false;
    }
    
    // Set protocol
    info.l4Protocol = Protocol::TCP;
    
    // Extract ports
    info.srcPort = (data[0] << 8) | data[1];
    info.dstPort = (data[2] << 8) | data[3];
    
    // Extract sequence and acknowledgment numbers
    info.tcpSeqNum = (data[4] << 24) | (data[5] << 16) | (data[6] << 8) | data[7];
    info.tcpAckNum = (data[8] << 24) | (data[9] << 16) | (data[10] << 8) | data[11];
    
    // Extract data offset and flags
    uint8_t dataOffset = (data[12] >> 4) & 0x0F;
    size_t tcpHeaderLen = dataOffset * 4;
    
    if (dataSize < tcpHeaderLen) {
        return false;
    }
    
    // Extract TCP flags
    info.tcpSyn = (data[13] & 0x02) != 0;
    info.tcpAck = (data[13] & 0x10) != 0;
    info.tcpFin = (data[13] & 0x01) != 0;
    info.tcpRst = (data[13] & 0x04) != 0;
    
    offset += tcpHeaderLen;
    return true;
}

bool PacketParser::parseUDPHeader(const uint8_t* data, size_t dataSize, PacketInfo& info, size_t& offset) {
    if (dataSize < 8) {
        return false;
    }
    
    // Set protocol
    info.l4Protocol = Protocol::UDP;
    
    // Extract ports
    info.srcPort = (data[0] << 8) | data[1];
    info.dstPort = (data[2] << 8) | data[3];
    
    // UDP header is always 8 bytes
    offset += 8;
    return true;
}

bool PacketParser::parse(const PcapPacketIterator::PacketView& packetView) {
    // Increment packet counter
    m_packetCount++;
    
    // Get packet data and size
    const uint8_t* packetData = packetView.dataStart;
    size_t packetSize = packetView.dataSize;
    
    // Initialize packet info
    PacketInfo info = {};
    info.timestamp = packetView.timestamp;
    info.l3Protocol = Protocol::UNKNOWN;
    info.l4Protocol = Protocol::UNKNOWN;
    
    // Parse Ethernet header
    size_t offset = 0;
    if (!parseEthernetHeader(packetData, packetSize, info, offset)) {
        PME_LOG_WARNING(log_, "Failed to parse Ethernet header");
        return false;
    }
    
    // Parse IP header based on EtherType
    if (info.etherType == 0x0800) {  // IPv4
        if (!parseIPv4Header(packetData + offset, packetSize - offset, info, offset)) {
            PME_LOG_WARNING(log_, "Failed to parse IPv4 header");
            return false;
        }
        
        // Parse next layer based on IP protocol
        if (info.ipProtocol == 6) {  // TCP
            if (!parseTCPHeader(packetData + offset, packetSize - offset, info, offset)) {
                PME_LOG_WARNING(log_, "Failed to parse TCP header");
                return false;
            }
        } else if (info.ipProtocol == 17) {  // UDP
            if (!parseUDPHeader(packetData + offset, packetSize - offset, info, offset)) {
                PME_LOG_WARNING(log_, "Failed to parse UDP header");
                return false;
            }
        }
        // Other protocols can be added here
    }
    // Support for IPv6 (0x86DD) can be added here
    
    // Set payload information
    info.payloadData = packetData + offset;
    info.payloadSize = packetSize - offset;
    
    // Store the packet info
    m_lastPacketInfo = info;
    
    // Call payload callback if set
    if (m_payloadCallback && info.payloadSize > 0) {
        m_payloadCallback(info, info.payloadData, info.payloadSize);
    }
    
    // Periodically log packet info
    if (m_packetCount % 10000 == 0) {
        PME_LOG_DEBUG(log_, "Parsed packet " << m_packetCount 
                  << " - " << info.srcIP.toString() << ":" << info.srcPort 
                  << " -> " << info.dstIP.toString() << ":" << info.dstPort
                  << " (payload: " << info.payloadSize << " bytes)");
    }
    
    return true;
}
Engine.cpp Updates
Update the Engine to set a payload callback:
cppCopyvoid Engine::init() {
    // ... existing code ...
    
    // Create packet parser
    m_parser = std::make_unique<PacketParser>();
    
    // Set payload callback
    static_cast<PacketParser*>(m_parser.get())->setPayloadCallback(
        [this](const PacketParser::PacketInfo& info, const uint8_t* payload, size_t size) {
            // This is where you would handle the proprietary protocol
            // For now, just a placeholder
            if (info.l4Protocol == PacketParser::Protocol::TCP && size > 0) {
                // Example of checking first few bytes of payload to identify protocol
                // if (size >= 4 && payload[0] == 0x12 && payload[1] == 0x34) {
                //     // Handle your proprietary protocol here
                // }
            }
        }
    );
    
    // ... rest of the method ...
}
Google Mock Tests
Now, let's write some GMock tests for PcapFileHandler, MMapHandler, and PacketParser. I'll show you how to set up these tests as examples, focusing on the most critical aspects of each component.
File Structure
First, let's organize our test files:
Copytests/
├── mocks/
│   ├── MockIPcapFileHandler.h
│   ├── MockIMMapHandler.h
│   └── MockIPacketParser.h
├── PcapFileHandlerTest.cpp
├── MMapHandlerTest.cpp
└── PacketParserTest.cpp
Mock Interfaces
MockIPcapFileHandler.h
cppCopy#pragma once

#include "IPcapFileHandler.h"
#include <gmock/gmock.h>

class MockIPcapFileHandler : public IPcapFileHandler {
public:
    MOCK_METHOD(void, scanDirectory, (), (override));
    MOCK_METHOD(void, setFileTransitionHandler, (std::function<void(const std::string&)>), (override));
    MOCK_METHOD(void, markCurrentFileProcessed, (), (override));
    MOCK_METHOD(bool, hasMoreFiles, (), (const, override));
    MOCK_METHOD(std::string, getCurrentFilePath, (), (const, override));
    MOCK_METHOD(FileState, getCurrentFileState, (), (const, override));
};
MockIMMapHandler.h
cppCopy#pragma once

#include "IMMapHandler.h"
#include <gmock/gmock.h>

class MockIMMapHandler : public IMMapHandler {
public:
    MOCK_METHOD(bool, processFile, (const std::string&), (override));
    MOCK_METHOD(void, unmapCurrentFile, (), (override));
    MOCK_METHOD(void, markCurrentFileProcessed, (), (override));
    MOCK_METHOD(void, resetProcessedFlag, (), (override));
    MOCK_METHOD(const uint8_t*, getMappedData, (), (const, override));
    MOCK_METHOD(size_t, getMappedSize, (), (const, override));
    MOCK_METHOD(void, setCompletionHandler, (std::function<void()>), (override));
};
MockIPacketParser.h
cppCopy#pragma once

#include "IPacketParser.h"
#include <gmock/gmock.h>

class MockIPacketParser : public IPacketParser {
public:
    MOCK_METHOD(bool, parse, (const PcapPacketIterator::PacketView&), (override));
    MOCK_METHOD(void, reset, (), (override));
};
Test Files
PcapFileHandlerTest.cpp
cppCopy#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <filesystem>
#include <fstream>
#include "PcapFileHandler.h"

namespace fs = std::filesystem;

class PcapFileHandlerTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Create a temporary test directory
        testDirPath = fs::temp_directory_path() / "pcap_test_dir";
        fs::create_directory(testDirPath);
        
        // Create some test PCAP files
        createTestPcapFile(testDirPath / "test1.pcap");
        createTestPcapFile(testDirPath / "test2.pcap");
        createTestPcapFile(testDirPath / "test3.txt");  // Not a PCAP file
    }
    
    void TearDown() override {
        // Clean up test directory
        fs::remove_all(testDirPath);
    }
    
    void createTestPcapFile(const fs::path& path) {
        std::ofstream file(path, std::ios::binary);
        // Write a valid PCAP global header (magic number, etc.)
        uint32_t magic = 0xa1b2c3d4;
        uint16_t major = 2;
        uint16_t minor = 4;
        uint32_t timezone = 0;
        uint32_t sigfigs = 0;
        uint32_t snaplen = 65535;
        uint32_t network = 1;  // Ethernet
        
        file.write(reinterpret_cast<char*>(&magic), sizeof(magic));
        file.write(reinterpret_cast<char*>(&major), sizeof(major));
        file.write(reinterpret_cast<char*>(&minor), sizeof(minor));
        file.write(reinterpret_cast<char*>(&timezone), sizeof(timezone));
        file.write(reinterpret_cast<char*>(&sigfigs), sizeof(sigfigs));
        file.write(reinterpret_cast<char*>(&snaplen), sizeof(snaplen));
        file.write(reinterpret_cast<char*>(&network), sizeof(network));
        
        file.close();
    }
    
    fs::path testDirPath;
};

// Test that scanDirectory finds only valid PCAP files
TEST_F(PcapFileHandlerTest, ScanDirectoryFindsValidPcapFiles) {
    PcapFileHandler handler(testDirPath.string());
    
    // Rescan the directory to ensure fresh results
    handler.scanDirectory();
    
    // Test that handler reports having files
    EXPECT_TRUE(handler.hasMoreFiles());
    
    // Keep track of processed files
    std::vector<std::string> processedFiles;
    
    // Set up transition handler to record files
    handler.setFileTransitionHandler([&processedFiles](const std::string& filePath) {
        processedFiles.push_back(filePath);
    });
    
    // Start processing and mark files as processed
    static_cast<PcapFileHandler&>(handler).startProcessing();
    handler.markCurrentFileProcessed();
    
    // We should get another file
    ASSERT_EQ(processedFiles.size(), 1);
    handler.markCurrentFileProcessed();
    
    // We should not have more files
    EXPECT_FALSE(handler.hasMoreFiles());
    ASSERT_EQ(processedFiles.size(), 2);
    
    // Verify the files we processed were the PCAP files
    std::vector<std::string> expectedFiles = {
        (testDirPath / "test1.pcap").string(),
        (testDirPath / "test2.pcap").string()
    };
    
    // Sort the vectors to ensure consistent comparison
    std::sort(processedFiles.begin(), processedFiles.end());
    std::sort(expectedFiles.begin(), expectedFiles.end());
    
    EXPECT_EQ(processedFiles, expectedFiles);
}

// Test that markCurrentFileProcessed transitions to the next file
TEST_F(PcapFileHandlerTest, MarkCurrentFileProcessedTransitionsToNextFile) {
    PcapFileHandler handler(testDirPath.string());
    
    // Set up transition handler
    int callCount = 0;
    std::string lastFile;
    
    handler.setFileTransitionHandler([&callCount, &lastFile](const std::string& filePath) {
        callCount++;
        lastFile = filePath;
    });
    
    // Start processing
    static_cast<PcapFileHandler&>(handler).startProcessing();
    
    // Verify we got the first transition
    EXPECT_EQ(callCount, 1);
    EXPECT_FALSE(lastFile.empty());
    
    // Get current state
    auto initialState = handler.getCurrentFileState();
    EXPECT_EQ(initialState, IPcapFileHandler::FileState::PROCESSING);
    
    // Store the initial file
    std::string firstFile = lastFile;
    
    // Mark as processed and verify we get another transition
    handler.markCurrentFileProcessed();
    
    // Verify we got the next transition
    EXPECT_EQ(callCount, 2);
    EXPECT_NE(lastFile, firstFile);
    
    // Verify the state is still correct
    auto newState = handler.getCurrentFileState();
    EXPECT_EQ(newState, IPcapFileHandler::FileState::PROCESSING);
}
MMapHandlerTest.cpp
cppCopy#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <filesystem>
#include <fstream>
#include "MMapHandler.h"

namespace fs = std::filesystem;

class MMapHandlerTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Create a temporary test file
        testFilePath = fs::temp_directory_path() / "test.pcap";
        createTestPcapFile(testFilePath);
    }
    
    void TearDown() override {
        // Clean up test file
        fs::remove(testFilePath);
    }
    
    void createTestPcapFile(const fs::path& path) {
        std::ofstream file(path, std::ios::binary);
        // Write a valid PCAP global header (magic number, etc.)
        uint32_t magic = 0xa1b2c3d4;
        uint16_t major = 2;
        uint16_t minor = 4;
        uint32_t timezone = 0;
        uint32_t sigfigs = 0;
        uint32_t snaplen = 65535;
        uint32_t network = 1;  // Ethernet
        
        file.write(reinterpret_cast<char*>(&magic), sizeof(magic));
        file.write(reinterpret_cast<char*>(&major), sizeof(major));
        file.write(reinterpret_cast<char*>(&minor), sizeof(minor));
        file.write(reinterpret_cast<char*>(&timezone), sizeof(timezone));
        file.write(reinterpret_cast<char*>(&sigfigs), sizeof(sigfigs));
        file.write(reinterpret_cast<char*>(&snaplen), sizeof(snaplen));
        file.write(reinterpret_cast<char*>(&network), sizeof(network));
        
        file.close();
    }
    
    fs::path testFilePath;
};

// Test that processFile correctly maps a valid PCAP file
TEST_F(MMapHandlerTest, ProcessFileMapsPcapFile) {
    MMapHandler handler;
    
    // Process the file
    EXPECT_TRUE(handler.processFile(testFilePath.string()));
    
    // Verify the file was mapped
    EXPECT_NE(handler.getMappedData(), nullptr);
    EXPECT_GT(handler.getMappedSize(), 0U);
    
    // Verify the magic number is correct
    uint32_t magic = *reinterpret_cast<const uint32_t*>(handler.getMappedData());
    EXPECT_EQ(magic, 0xa1b2c3d4);
}

// Test that unmapCurrentFile correctly cleans up resources
TEST_F(MMapHandlerTest, UnmapCurrentFileCleanupResources) {
    MMapHandler handler;
    
    // Process the file
    EXPECT_TRUE(handler.processFile(testFilePath.string()));
    
    // Verify the file was mapped
    EXPECT_NE(handler.getMappedData(), nullptr);
    EXPECT_GT(handler.getMappedSize(), 0U);
    
    // Unmap the file
    handler.unmapCurrentFile();
    
    // Verify resources were cleaned up
    EXPECT_EQ(handler.getMappedData(), nullptr);
    EXPECT_EQ(handler.getMappedSize(), 0U);
}

// Test that completion handler is only called when explicitly marked as processed
TEST_F(MMapHandlerTest, CompletionHandlerCalledWhenMarkedProcessed) {
    MMapHandler handler;
    
    // Set up completion handler
    bool handlerCalled = false;
    handler.setCompletionHandler([&handlerCalled]() {
        handlerCalled = true;
    });
    
    // Process the file
    EXPECT_TRUE(handler.processFile(testFilePath.string()));
    
    // Unmap without marking as processed
    handler.unmapCurrentFile();
    
    // Handler should not have been called
    EXPECT_FALSE(handlerCalled);
    
    // Process the file again
    EXPECT_TRUE(handler.processFile(testFilePath.string()));
    
    // Mark as processed
    handler.markCurrentFileProcessed();
    
    // Unmap again
    handler.unmapCurrentFile();
    
    // Handler should have been called
    EXPECT_TRUE(handlerCalled);
}
PacketParserTest.cpp
cppCopy#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include "PacketParser.h"

class PacketParserTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Create a fake packet buffer
        createFakeIPv4TCPPacket();
        createFakeIPv4UDPPacket();
    }
    
    void createFakeIPv4TCPPacket() {
        // Ethernet header (14 bytes)
        uint8_t ethernetHeader[] = {
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55,  // Destination MAC
            0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB,  // Source MAC
            0x08, 0x00                           // EtherType (IPv4)
        };
        
        // IPv4 header (20 bytes)
        uint8_t ipv4Header[] = {
            0x45, 0x00,                          // Version, IHL, ToS
            0x00, 0x28,                          // Total Length
            0x12, 0x34,                          // Identification
            0x40, 0x00,                          // Flags, Fragment Offset
            0x40, 0x06,                          // TTL, Protocol (TCP)
            0x00, 0x00,                          // Header Checksum
            0xC0, 0xA8, 0x01, 0x01,              // Source IP (192.168.1.1)
            0xC0, 0xA8, 0x01, 0x02               // Destination IP (192.168.1.2)
        };
        
        // TCP header (20 bytes)
        uint8_t tcpHeader[] = {
            0x12, 0x34,                          // Source Port (4660)
            0x45, 0x67,                          // Destination Port (17767)
            0x00, 0x00, 0x00, 0x01,              // Sequence Number
            0x00, 0x00, 0x00, 0x02,              // Acknowledgment Number
            0x50, 0x18,                          // Data Offset, Flags (ACK, PSH)
            0x10, 0x00,                          // Window
            0x00, 0x00,                          // Checksum
            0x00, 0x00                           // Urgent Pointer
        };
        
        // Payload (10 bytes)
        uint8_t payload[] = {
            0x48, 0x65, 0x6C, 0x6C, 0x6F,        // "Hello"
            0x20, 0x57, 0x6F, 0x72, 0x6C, 0x64   // " World"
        };
        
        // Combine everything into TCP packet
        tcpPacket.reserve(sizeof(ethernetHeader) + sizeof(ipv4Header) + sizeof(tcpHeader) + sizeof(payload));
        tcpPacket.insert(tcpPacket.end(), ethernetHeader, ethernetHeader + sizeof(ethernetHeader));
        tcpPacket.insert(tcpPacket.end(), ipv4Header, ipv4Header + sizeof(ipv4Header));
        tcpPacket.insert(tcpPacket.end(), tcpHeader, tcpHeader + sizeof(tcpHeader));
        tcpPacket.insert(tcpPacket.end(), payload, payload + sizeof(payload));
    }
    
    void createFakeIPv4UDPPacket() {
        // Ethernet header (14 bytes)
        uint8_t ethernetHeader[] = {
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55,  // Destination MAC
            0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB,  // Source MAC
            0x08, 0x00                           // EtherType (IPv4)
        };
        
        // IPv4 header (20 bytes)
        uint8_t ipv4Header[] = {
            0x45, 0x00,                          // Version, IHL, ToS
            0x00, 0x28,                          // Total Length
            0x12, 0x34,                          // Identification
            0x40, 0x00,                          // Flags, Fragment Offset
            0x40, 0x11,                          // TTL, Protocol (UDP)
            0x00, 0x00,                          // Header Checksum
            0xC0, 0xA8, 0x01, 0x01,              // Source IP (192.168.1.1)
            0xC0, 0xA8, 0x01, 0x02               // Destination IP (192.168.1.2)
        };
        
        // UDP header (8 bytes)
        uint8_t udpHeader[] = {
            0x12, 0x34,                          // Source Port (4660)
            0x45, 0x67,                          // Destination Port (17767)
            0x00, 0x12,                          // Length
            0x00, 0x00                           // Checksum
        };
        
        // Payload (10 bytes)
        uint8_t payload[] = {
            0x48, 0x65, 0x6C, 0x6C, 0x6F,        // "Hello"
            0x20, 0x57, 0x6F, 0x72, 0x6C, 0x64   // " World"
        };
        
        // Combine everything into UDP packet
        udpPacket.reserve(sizeof(ethernetHeader) + sizeof(ipv4Header) + sizeof(udpHeader) + sizeof(payload));
        udpPacket.insert(udpPacket.end(), ethernetHeader, ethernetHeader + sizeof(ethernetHeader));
        udpPacket.insert(udpPacket.end(), ipv4Header, ipv4Header + sizeof(ipv4Header));
        udpPacket.insert(udpPacket.end(), udpHeader, udpHeader + sizeof(udpHeader));
        udpPacket.insert(udpPacket.end(), payload, payload + sizeof(payload));
    }
    
    std::vector<uint8_t> tcpPacket;
    std::vector<uint8_t> udpPacket;
};

// Test that parser correctly parses TCP packet
TEST_F(PacketParserTest, ParseTCPPacket) {
    PacketParser parser;
    
    // Create packet view
    PcapPacketIterator::PacketView view;
    view.dataStart = tcpPacket.data();
    view.dataSize = tcpPacket.size();
    view.timestamp = std::chrono::system_clock::now();
    
    // Parse the packet
    EXPECT_TRUE(parser.parse(view));
    
    // Verify packet count
    EXPECT_EQ(parser.getPacketCount(), 1U);
    
    // Get parsed packet info
    const auto& info = parser.getLastPacketInfo();
    
    // Verify Ethernet layer
    EXPECT_EQ(info.srcMac, "66:77:88:99:aa:bb");
    EXPECT_EQ(info.dstMac, "00:11:22:33:44:55");
    EXPECT_EQ(info.etherType, 0x0800);  // IPv4
    
    // Verify IP layer
    EXPECT_EQ(info.l3Protocol, PacketParser::Protocol::IPv4);
    EXPECT_EQ(info.srcIP.toString(), "192.168.1.1");
    EXPECT_EQ(info.dstIP.toString(), "192.168.1.2");
    EXPECT_EQ(info.ipProtocol, 6);  // TCP
    
    // Verify TCP layer
    EXPECT_EQ(info.l4Protocol, PacketParser::Protocol::TCP);
    EXPECT_EQ(info.srcPort, 0x1234);  // 4660
    EXPECT_EQ(info.dstPort, 0x4567);  // 17767
    EXPECT_EQ(info.tcpSeqNum, 1U);
    EXPECT_EQ(info.tcpAckNum, 2U);
    EXPECT_TRUE(info.tcpAck);
    
    // Verify payload
    EXPECT_NE(info.payloadData, nullptr);
    EXPECT_GT(info.payloadSize, 0U);
}

// Test that parser correctly parses UDP packet
TEST_F(PacketParserTest, ParseUDPPacket) {
    PacketParser parser;
    
    // Create packet view
    PcapPacketIterator::PacketView view;
    view.dataStart = udpPacket.data();
    view.dataSize = udpPacket.size();
    view.timestamp = std::chrono::system_clock::now();
    
    // Parse the packet
    EXPECT_TRUE(parser.parse(view));
    
    // Verify packet count
    EXPECT_EQ(parser.getPacketCount(), 1U);
    
    // Get parsed packet info
    const auto& info = parser.getLastPacketInfo();
    
    // Verify Ethernet layer
    EXPECT_EQ(info.srcMac, "66:77:88:99:aa:bb");
    EXPECT_EQ(info.dstMac, "00:11:22:33:44:55");
    EXPECT_EQ(info.etherType, 0x0800);  // IPv4
    
    // Verify IP layer
    EXPECT_EQ(info.l3Protocol, PacketParser::Protocol::IPv4);
    EXPECT_EQ(info.srcIP.toString(), "192.168.1.1");
    EXPECT_EQ(info.dstIP.toString(), "192.168.1.2");
    EXPECT_EQ(info.ipProtocol, 17);  // UDP
    
    // Verify UDP layer
    EXPECT_EQ(info.l4Protocol, PacketParser::Protocol::UDP);
    EXPECT_EQ(info.srcPort, 0x1234);  // 4660
    EXPECT_EQ(info.dstPort, 0x4567);  // 17767
    
    // Verify payload
    EXPECT_NE(info.payloadData, nullptr);
    EXPECT_GT(info.payloadSize, 0U);
}

// Test that payload callback is called
TEST_F(PacketParserTest, PayloadCallbackIsCalled) {
    PacketParser parser;
    
    // Set up payload callback
    bool callbackCalled = false;
    const uint8_t* callbackPayload = nullptr;
    size_t callbackSize = 0;
    
    parser.setPayloadCallback([&](const PacketParser::PacketInfo& info, const uint8_t* payload, size_t size) {
        callbackCalled = true;
        callbackPayload = payload;
        callbackSize = size;
    });
    
    // Create packet view
    PcapPacketIterator::PacketView view;
    view.dataStart = tcpPacket.data();
    view.dataSize = tcpPacket.size();
    view.timestamp = std::chrono::system_clock::now();
    
    // Parse the packet
    EXPECT_TRUE(parser.parse(view));
    
    // Verify callback was called
    EXPECT_TRUE(callbackCalled);
    EXPECT_NE(callbackPayload, nullptr);
    EXPECT_GT(callbackSize, 0U);
    
    // Verify payload data
    EXPECT_EQ(callbackPayload[0], 'H');
    EXPECT_EQ(callbackPayload[1], 'e');
    EXPECT_EQ(callbackPayload[2], 'l');
    EXPECT_EQ(callbackPayload[3], 'l');
    EXPECT_EQ(callbackPayload[4], 'o');
}
Comprehensive Unit Test List
Here's a comprehensive list of unit tests that would be impressive for a junior developer to implement:
PcapFileHandler Tests

ScanDirectoryFindsValidPcapFiles - Verifies that only valid PCAP files are detected
MarkCurrentFileProcessedTransitionsToNextFile - Tests file state transitions
EmptyDirectoryHandledGracefully - Verifies behavior with no files
InvalidDirectoryHandledGracefully - Tests error handling with non-existent directory
FileStateTransitionsCorrectly - Tests full state machine of file states
FilesAreSortedByTimestamp - Verifies files are processed in correct order
CallbackFunctionCalledCorrectly - Tests callback behavior
ScanDirectoryUpdatesProperly - Verifies rescanning works correctly
StartProcessingWithNoFiles - Tests edge case of starting with no files
ConcurrentAccessThreadSafety - Tests thread safety (with multiple threads)

MMapHandler Tests

ProcessFileMapsPcapFile - Verifies mapping of valid file
UnmapCurrentFileCleanupResources - Tests resource cleanup
CompletionHandlerCalledWhenMarkedProcessed - Tests callback behavior
InvalidFileHandledGracefully - Tests error handling
EmptyFileHandledGracefully - Tests edge case
TruncatedFileHandledGracefully - Tests error handling for corrupted file
InvalidMagicNumberDetected - Tests validation of PCAP header
ResetProcessedFlagBehavior - Tests explicit flag reset
LargeFileHandling - Tests performance with large files
MultipleProcessFileCallsCleanup - Tests proper cleanup between files

PacketParser Tests

ParseTCPPacket - Verifies TCP packet parsing
ParseUDPPacket - Verifies UDP packet parsing
PayloadCallbackIsCalled - Tests callback behavior
ParseInvalidPacket - Tests error handling
ParseTruncatedPacket - Tests error handling for truncated packets
ResetClearsState - Verifies reset behavior
IPv6PacketParsing - Tests IPv6 support
ARPPacketParsing - Tests ARP packet parsing
ICMPPacketParsing - Tests ICMP packet parsing
VLANTaggedPacketParsing - Tests VLAN tagging support
IPFragmentationHandling - Tests IP fragment handling
TCPOptionsHandling - Tests TCP options parsing
PacketWithPadding - Tests handling of padded packets
MalformedHeaderHandling - Tests robustness against malformed headers
PerformanceWithLargePackets - Tests performance with large packets

Engine Integration Tests

EndToEndFileProcessing - Tests complete processing pipeline
GracefulShutdownDuringProcessing - Tests shutdown behavior
ErrorHandlingAndRecovery - Tests error recovery
ProcessingMultipleFiles - Tests file transitions
MemoryUsageWithLargeFiles - Tests memory efficiency

PcapPacketIterator Tests

ValidPacketIteration - Tests basic iteration
CorruptHeaderDetection - Tests error handling
TruncatedPacketDetection - Tests error handling
EndOfFileDetection - Tests EOF detection
ByteSwapHandling - Tests endianness handling

This comprehensive test suite covers not just basic functionality but also edge cases, error conditions, performance aspects, and thread safety - demonstrating a senior-level understanding of robust testing practices.
